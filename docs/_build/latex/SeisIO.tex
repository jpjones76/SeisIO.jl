%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,11pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Introduction}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{SeisIO Documentation}
\date{May 16, 2019}
\release{0.2.0}
\author{Joshua Jones}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\maketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


SeisIO is a collection of utilities for reading and downloading geophysical timeseries data.


\chapter{Intro}
\label{\detokenize{index:intro}}

\section{Introduction}
\label{\detokenize{src/intro:introduction}}\label{\detokenize{src/intro::doc}}
SeisIO is a framework for working with univariate geophysical data.
SeisIO is designed around three basic principles:
\begin{itemize}
\item {} 
Ease of use: you shouldn’t \sphinxstyleemphasis{need} a PhD to study geophysical data.

\item {} 
Fluidity: working with data shouldn’t feel \sphinxstyleemphasis{clumsy}.

\item {} 
Performance: speed and efficient memory usage \sphinxstyleemphasis{matter}.

\end{itemize}

The project is home to an expanding set of web clients, file format readers,
and analysis utilities.


\subsection{Overview}
\label{\detokenize{src/intro:overview}}
SeisIO stores data in minimalist containers that track the bare necessities for
analysis. New data are easily added with basic commands like \sphinxcode{\sphinxupquote{+}}. Unwanted
channels can be removed just as easily. Data can be saved to a native SeisIO
format or written to other supported file formats.


\subsection{Installation}
\label{\detokenize{src/intro:installation}}
From the Julia prompt: press \sphinxcode{\sphinxupquote{{]}}} to enter the Pkg environment, then type

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{add} \PYG{n}{SeisIO}\PYG{p}{;} \PYG{n}{build}\PYG{p}{;} \PYG{n}{precompile}
\end{sphinxVerbatim}

Dependencies should install automatically. To verify that everything works
correctly, type

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{test} \PYG{n}{SeisIO}
\end{sphinxVerbatim}

and allow 10-20 minutes for tests to complete. To get started, exit the Pkg
environment by pressing Backspace or Control + C, then type

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{using} \PYG{n}{SeisIO}
\end{sphinxVerbatim}

at the Julia prompt. You’ll need to repeat that last step whenever you restart
Julia, as with any command-line interpreter (CLI) language.


\subsection{Getting Started}
\label{\detokenize{src/intro:getting-started}}
The {\hyperref[\detokenize{src/tutorial:tutorial}]{\sphinxcrossref{\DUrole{std,std-ref}{tutorial}}}} is designed as a gentle introduction for people
less familiar with the Julia language. If you already have some familiarity
with Julia, you probably want to start with one of the following topics:
\begin{itemize}
\item {} 
{\hyperref[\detokenize{src/working_with_data:wwd}]{\sphinxcrossref{\DUrole{std,std-ref}{Working with Data}}}}: learn how to manage data using SeisIO

\item {} 
{\hyperref[\detokenize{src/Formats/fileformats:readdata}]{\sphinxcrossref{\DUrole{std,std-ref}{Reading Data}}}}: learn how to read data from file

\item {} 
{\hyperref[\detokenize{src/Web/webclients:getdata}]{\sphinxcrossref{\DUrole{std,std-ref}{Requesting Data}}}}: learn how to make web requests

\end{itemize}


\subsection{Updating}
\label{\detokenize{src/intro:updating}}
From the Julia prompt: press \sphinxcode{\sphinxupquote{{]}}} to enter the Pkg environment, then type
\sphinxcode{\sphinxupquote{update}}. Once updates finish, restart Julia to use them.


\subsection{Getting Help}
\label{\detokenize{src/intro:getting-help}}
In addition to these documents, a number of help documents can be called at the
Julia prompt. These commands are a useful starting point:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
?chanspec           \PYGZsh{} how to specify channels in web requests
?get\PYGZus{}data           \PYGZsh{} how to download data
?read\PYGZus{}data          \PYGZsh{} how to read data from file
?timespec           \PYGZsh{} how to specify times in web requests and data processing
?seed\PYGZus{}support       \PYGZsh{} how much of the SEED data standard is supported?
?seis\PYGZus{}www           \PYGZsh{} list strings for data sources in web requests
?SeisData           \PYGZsh{} information about SeisIO data types
?SeisIO.KW          \PYGZsh{} SeisIO shared keywords and their meanings
\end{sphinxVerbatim}


\section{First Steps}
\label{\detokenize{src/tutorial:first-steps}}\label{\detokenize{src/tutorial:tutorial}}\label{\detokenize{src/tutorial::doc}}
SeisIO is designed around easy, fluid, and fast data access.
At the most basic level, SeisIO uses an array-like custom object called a
\sphinxstylestrong{SeisChannel} for single-channel data; \sphinxstylestrong{SeisData} objects store
multichannel data and can be created by combining SeisChannels.


\subsection{Start Here}
\label{\detokenize{src/tutorial:start-here}}
Create a new, empty \sphinxstylestrong{SeisChannel} object with


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{Ch~=~SeisChannel()}}}
\end{fulllineitems}


The meanings of the field names are explained {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{here}}}}; you can also type
\sphinxcode{\sphinxupquote{?SeisChannel}} at the Julia prompt. You can edit field values manually, e.g.,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ch}\PYG{o}{.}\PYG{n}{loc} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{90.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{9300.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{]}
\PYG{n}{Ch}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{South pole}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

or you can set them with keywords at creation:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ch} \PYG{o}{=} \PYG{n}{SeisChannel}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MANOWAR JAJAJA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

SeisData structures are collections of channel data. They can be created with
the SeisData() command, which can optionally create any number of empty channels
at a time, e.g.,


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{S~=~SeisData(1)}}}
\end{fulllineitems}


They can be explored similarly:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S}\PYG{o}{.}\PYG{n}{name}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{South pole}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{S}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{90.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{9300.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{]}
\end{sphinxVerbatim}

A collection of channels becomes a SeisData structure:


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{S~=~SeisData(SeisChannel(),~SeisChannel())}}}
\end{fulllineitems}


You can push channels onto existing SeisData structures, like adding one key
to a dictionary:


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{push!(S,~Ch)}}}
\end{fulllineitems}


Note that this copies Ch to a new channel in S \textendash{} S{[}3{]} is not a view into C.
This is deliberate, as otherwise the workspace quickly becomes a mess of
redundant channels. Clean up with \sphinxcode{\sphinxupquote{Ch = {[}{]}}} to free memory before moving on.


\subsection{Operations on SeisData structures}
\label{\detokenize{src/tutorial:operations-on-seisdata-structures}}
We’re now ready for a short tutorial of what we can do with data structures.
In the commands below, as in most of this documentation, \sphinxstylestrong{Ch} is a
SeisChannel object and \sphinxstylestrong{S} is a SeisData object.


\subsubsection{Adding channels to a SeisData structure}
\label{\detokenize{src/tutorial:adding-channels-to-a-seisdata-structure}}
You’ve already seen one way to add a channel to SeisData: push!(S, SeisChannel())
adds an empty channel. Here are others:


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{append!(S,~SeisData(n))}}}
\end{fulllineitems}


Adds n channels to the end of S by creating a new n-channel SeisData and
appending it, similar to adding two dictionaries together.

These methods are aliased to the addition operator:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S} \PYG{o}{+}\PYG{o}{=} \PYG{n}{SeisChannel}\PYG{p}{(}\PYG{p}{)}      \PYG{c+c1}{\PYGZsh{} equivalent to push!(S, SeisChannel())}
\PYG{n}{S} \PYG{o}{+}\PYG{o}{=} \PYG{n}{randseisdata}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} adds a random 3\PYGZhy{}element SeisData structure to S in place}
\PYG{n}{S} \PYG{o}{=} \PYG{n}{SeisData}\PYG{p}{(}\PYG{n}{randseisdata}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{SeisChannel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
      \PYG{n}{SeisChannel}\PYG{p}{(}\PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UW.SEP..EHZ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Darth Exploded}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
      \PYG{n}{loc}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{46.1967}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{122.1875}\PYG{p}{,} \PYG{l+m+mi}{1440}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Most web request functions can append to an existing SeisData object by placing
an exclamation mark after the function call. You can see how this works by
running the {\hyperref[\detokenize{src/Appendices/examples:webex}]{\sphinxcrossref{\DUrole{std,std-ref}{examples}}}}.


\subsubsection{Search, Sort, and Prune}
\label{\detokenize{src/tutorial:search-sort-and-prune}}
The easiest way to find channels of interest in a data structure is to
use findid, but you can obtain an array of partial matches with findchan:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S} \PYG{o}{=} \PYG{n}{SeisData}\PYG{p}{(}\PYG{n}{randseisdata}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{SeisChannel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
      \PYG{n}{SeisChannel}\PYG{p}{(}\PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UW.SEP..EHZ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Darth Exploded}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
      \PYG{n}{loc}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{46.1967}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{122.1875}\PYG{p}{,} \PYG{l+m+mi}{1440}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{findid}\PYG{p}{(}\PYG{n}{S}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UW.SEP..EHZ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} 7}
\PYG{n}{findchan}\PYG{p}{(}\PYG{n}{S}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EHZ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}          \PYG{c+c1}{\PYGZsh{} [7], maybe others depending on randseisdata}
\end{sphinxVerbatim}

You can sort by channel ID with the \sphinxtitleref{sort} command.

Several functions exist to prune empty and unwanted channels from SeisData
structures.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
delete!(S, 1:2)  \PYGZsh{} Delete first two channels of S
S \PYGZhy{}= 3           \PYGZsh{} Delete third channel of S

\PYGZsh{} Extract S[1] as a SeisChannel, removing it from S
C = pull(S, 1)

\PYGZsh{} Delete all channels whose S.x is empty
prune!(S)

\PYGZsh{} Delete channels containing \PYGZdq{}.SEP.\PYGZdq{}
delete!(S, \PYGZdq{}.SEP.\PYGZdq{}, exact=false)
\end{sphinxVerbatim}

In the last example, specifying exact=false means that any channel whose ID
partly matches the string “.SEP.” gets deleted; by default, passing
a string to delete!(S, str) only matches channels where str is the exact ID.
This is an efficient way to remove unresponsive subnets and unwanted channel
types, but beware of clumsy over-matching.


\subsection{Next Steps}
\label{\detokenize{src/tutorial:next-steps}}
Because tracking arbitrary operations can be difficult, several functions have
been written to keep track of data and operations in a semi-automated way. See
the next section, {\hyperref[\detokenize{src/working_with_data:wwd}]{\sphinxcrossref{\DUrole{std,std-ref}{working with data}}}}, for detailed discussion of
managing data from the Julia command prompt.


\section{Working with Data}
\label{\detokenize{src/working_with_data:working-with-data}}\label{\detokenize{src/working_with_data:wwd}}\label{\detokenize{src/working_with_data::doc}}
This section describes how to track and manage SeisIO data.


\subsection{Creating Data Containers}
\label{\detokenize{src/working_with_data:creating-data-containers}}
Create a new, empty object using any of the following commands:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{7}|\X{6}{7}|}
\hline
\sphinxstyletheadfamily 
Object
&\sphinxstyletheadfamily 
Purpose
\\
\hline
SeisChannel()
&
A single channel of univariate (usually time-series) data
\\
\hline
SeisData()
&
Multichannel univariate (usually time-series) data
\\
\hline
SeisHdr()
&
Header structure for discrete seismic events
\\
\hline
SeisEvent()
&
Discrete seismic events; includes SeisHdr and SeisData objects
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{Acquiring Data}
\label{\detokenize{src/working_with_data:acquiring-data}}\begin{itemize}
\item {} 
Read files with {\hyperref[\detokenize{src/Formats/fileformats:readdata}]{\sphinxcrossref{\DUrole{std,std-ref}{read\_data}}}}

\item {} 
Make web requets with {\hyperref[\detokenize{src/Web/webclients:getdata}]{\sphinxcrossref{\DUrole{std,std-ref}{get\_data}}}}

\item {} 
Initiate real-time streaming sessions to SeisData objects with {\hyperref[\detokenize{src/Web/seedlink:seedlink-section}]{\sphinxcrossref{\DUrole{std,std-ref}{SeedLink!}}}}

\end{itemize}


\subsection{Keeping Track}
\label{\detokenize{src/working_with_data:keeping-track}}
A number of auxiliary functions exist to keep track of channels:
\index{findchan() (built-in function)@\spxentry{findchan()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/working_with_data:findchan}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{findchan}}}{\emph{id::String}, \emph{S::SeisData}}{}
\end{fulllineitems}

\index{findchan() (built-in function)@\spxentry{findchan()}\spxextra{built-in function}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{findchan}}}{\emph{S::SeisData}, \emph{id::String}}{}
\end{fulllineitems}


Get all channel indices i in S with id \(\in\) S.id{[}i{]}. Can do partial id
matches, e.g. findchan(S, “UW.”) returns indices to all channels whose IDs begin
with “UW.”.
\index{findid() (built-in function)@\spxentry{findid()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/working_with_data:findid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{findid}}}{\emph{S::SeisData}, \emph{id}}{}
\end{fulllineitems}


Return the index of the first channel in \sphinxstylestrong{S} where id = \sphinxstylestrong{id}. Requires an
exact string match; intended as a low-memory equivalent to findfirst for
ids.
\index{findid() (built-in function)@\spxentry{findid()}\spxextra{built-in function}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{findid}}}{\emph{S::SeisData}, \emph{Ch::SeisChannel}}{}
\end{fulllineitems}


Equivalent to findfirst(S.id.==Ch.id).


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{namestrip!(S{[},~convention{]})}}}
\end{fulllineitems}


Remove bad characters from the :name fields of \sphinxstylestrong{S}. Specify convention as a
string (default is “File”):


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Convention
&\sphinxstyletheadfamily 
Characters Removed:sup:\sphinxtitleref{(a)}
\\
\hline
“File”
&
\sphinxcode{\sphinxupquote{"\$*/:\textless{}\textgreater{}?@\textbackslash{}\textasciicircum{}\textbar{}\textasciitilde{}DEL}}
\\
\hline
“HTML”
&
\sphinxcode{\sphinxupquote{"\&';\textless{}\textgreater{}©DEL}}
\\
\hline
“Julia”
&
\sphinxcode{\sphinxupquote{\$\textbackslash{}DEL}}
\\
\hline
“Markdown”
&
\sphinxcode{\sphinxupquote{!\#()*+-.{[}\textbackslash{}{]}\_{}`\{\}}}
\\
\hline
“SEED”
&
\sphinxcode{\sphinxupquote{.DEL}}
\\
\hline
“Strict”
&
\sphinxcode{\sphinxupquote{!"\#\$\%\&'()*+,-./:;\textless{}=\textgreater{}?@{[}\textbackslash{}{]}\textasciicircum{}{}`\{\textbar{}\}\textasciitilde{}DEL}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

$^{\text{(a)}}$ \sphinxcode{\sphinxupquote{DEL}} here is \textbackslash{}x7f (ASCII/Unicode U+007f).
\index{timestamp() (built-in function)@\spxentry{timestamp()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/working_with_data:timestamp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{timestamp}}}{}{}
\end{fulllineitems}


Return current UTC time formatted yyyy-mm-ddTHH:MM:SS.\(\mu\)\(\mu\)\(\mu\).


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{track\_off!(S)}}}
\end{fulllineitems}


Turn off tracking in S and return a boolean vector of which channels were added
or altered significantly.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{track\_on!(S)}}}
\end{fulllineitems}


Begin tracking changes in S. Tracks changes to :id, channel additions, and
changes to data vector sizes in S.x.

Does not track data processing operations on any channel i unless
length(S.x{[}i{]}) changes for channel i (e.g. filtering is not tracked).

\sphinxstylestrong{Warning}: If you have or suspect gapped data in any channel, calling
ungap! while tracking is active will flag a channel as changed.


\subsubsection{Source Logging}
\label{\detokenize{src/working_with_data:source-logging}}
The :src field records the \sphinxstyleemphasis{last} source used to populate each channel (usually
a file name and path or a web request URL).

When a data source is added to a channel, including the first time data are
added, this is recorded in :notes with the syntax (timestamp) +src: (function) (src).


\subsection{Channel Maintenance}
\label{\detokenize{src/working_with_data:channel-maintenance}}
A few functions exist specifically to simplify data maintenance:


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{prune!(S::SeisData)}}}
\end{fulllineitems}


Delete all channels from S that have no data (i.e. S.x is empty or non-existent).


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{C~=~pull(S::SeisData,~id::String)}}}
\end{fulllineitems}


Extract the first channel with id=id from S and return it as a new SeisChannel
structure. The corresponding channel in S is deleted.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{C~=~pull(S::SeisData,~i::integer)}}}
\end{fulllineitems}


Extract channel \sphinxstylestrong{i} from \sphinxstylestrong{S} as a new SeisChannel object \sphinxstylestrong{C}, and delete
the corresponding channel from \sphinxstylestrong{S}.


\subsection{Taking Notes}
\label{\detokenize{src/working_with_data:taking-notes}}
Functions that add and process data note these operations in the :notes field
of each object affected. One can also add custom notes with the note! command:


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{note!(S,~i,~str)}}}
\end{fulllineitems}


Append \sphinxstylestrong{str} with a timestamp to the :notes field of channel number \sphinxstylestrong{i} of \sphinxstylestrong{S}.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{note!(S,~id,~str)}}}
\end{fulllineitems}


As above for the first channel in \sphinxstylestrong{S} whose id is an exact match to \sphinxstylestrong{id}.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{note!(S,~str)}}}
\end{fulllineitems}


if \sphinxstylestrong{str* mentions a channel name or ID, only the corresponding channel(s) in **S} is annotated; otherwise, all channels are annotated.

Clear all notes from channel \sphinxcode{\sphinxupquote{i}} of \sphinxcode{\sphinxupquote{S}}.

\sphinxcode{\sphinxupquote{clear\_notes!(S, id)}}

Clear all notes from the first channel in \sphinxcode{\sphinxupquote{S}} whose id field exactly matches \sphinxcode{\sphinxupquote{id}}.

\sphinxcode{\sphinxupquote{clear\_notes!(S)}}

Clear all notes from every channel in \sphinxcode{\sphinxupquote{S}}.


\chapter{Files}
\label{\detokenize{index:files}}

\section{Reading Files}
\label{\detokenize{src/Formats/fileformats:reading-files}}\label{\detokenize{src/Formats/fileformats:readdata}}\label{\detokenize{src/Formats/fileformats::doc}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{read\_data!(S,~fmt::String,~filepat~{[},~KWs{]})}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{S~=~read\_data(fmt::String,~filepat~{[},~KWs{]})}}}
\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] Read data from a supported file format into memory.
\item[] 
\item[] \sphinxstylestrong{fmt}
\item[] Lowercase string describin the file format. See below.
\item[] 
\item[] \sphinxstylestrong{filepat}
\item[] Read files with names matching pattern \sphinxcode{\sphinxupquote{filepat}}. Supports wildcards.
\item[] 
\item[] \sphinxstylestrong{KWs}
\item[] Keyword arguments; see also {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{SeisIO standard KWs}}}} or type \sphinxcode{\sphinxupquote{?SeisIO.KW}}.
\item[] Standard keywords: full, nx\_add, nx\_new, v
\item[] Other keywords: See below.
\end{DUlineblock}


\subsection{Supported File Formats}
\label{\detokenize{src/Formats/fileformats:supported-file-formats}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{2}{3}|\X{1}{3}|}
\hline
\sphinxstyletheadfamily 
File Format
&\sphinxstyletheadfamily 
String
\\
\hline
GeoCSV, time-sample pair
&
geocsv
\\
\hline
GeoCSV, sample list
&
geocsv.slist
\\
\hline
Lennartz ASCII
&
lenartzascii
\\
\hline
Mini-SEED, SEED
&
mseed
\\
\hline
PASSCAL SEG Y
&
passcal
\\
\hline
SAC
&
sac
\\
\hline
SEG Y (rev 0 or rev 1)
&
segy
\\
\hline
UW
&
uw
\\
\hline
Win32
&
win32
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

Strings are case-sensitive to prevent any performance impact from using matches
and/or lowercase().


\subsection{Supported Keywords}
\label{\detokenize{src/Formats/fileformats:supported-keywords}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{8}|\X{1}{8}|\X{1}{8}|\X{1}{8}|\X{4}{8}|}
\hline
\sphinxstyletheadfamily 
KW
&\sphinxstyletheadfamily 
Used By
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Default
&\sphinxstyletheadfamily 
Meaning
\\
\hline
cf
&
win32
&
String
&
“”
&
win32 channel info filestr
\\
\hline
full
&
sac
&
Bool
&
false
&
read full header into \sphinxstylestrong{:misc}?
\\
\hline&
segy
&&&\\
\hline&
uw
&&&\\
\hline
nx\_add
&
mseed
&
Int64
&
360000
&
minimum size increase of \sphinxstylestrong{:x}
\\
\hline
nx\_new
&
mseed
&
Int64
&
86400000
&
length of \sphinxstylestrong{:x} for new channels
\\
\hline
jst
&
win32
&
Bool
&
true
&
are sample times JST (UTC+9)?
\\
\hline
swap
&
seed
&
Bool
&
true
&
byte swap?
\\
\hline
v
&
mseed
&
Int64
&
0
&
verbosity
\\
\hline&
uw
&&&\\
\hline&
win32
&&&\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Performance Tip}
\label{\detokenize{src/Formats/fileformats:performance-tip}}
With mseed or win32 data, adjust \sphinxtitleref{nx\_new} and \sphinxtitleref{nx\_add} based on the sizes of
the data vectors that you expect to read. If the largest has \sphinxtitleref{Nmax} samples,
and the smallest has \sphinxtitleref{Nmin}, we recommend \sphinxtitleref{nx\_new=Nmin} and \sphinxtitleref{nx\_add=Nmax-Nmin}.

Default values can be changed in SeisIO keywords, e.g.,

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SeisIO}\PYG{o}{.}\PYG{n}{KW}\PYG{o}{.}\PYG{n}{nx\PYGZus{}new} \PYG{o}{=} \PYG{l+m+mi}{60000}
\PYG{n}{SeisIO}\PYG{o}{.}\PYG{n}{KW}\PYG{o}{.}\PYG{n}{nx\PYGZus{}add} \PYG{o}{=} \PYG{l+m+mi}{360000}
\end{sphinxVerbatim}

The system-wide defaults are \sphinxtitleref{nx\_new=86400000} and \sphinxtitleref{nx\_add=360000}. Using these
values with very small jobs will greatly decrease performance.


\paragraph{Examples}
\label{\detokenize{src/Formats/fileformats:examples}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{S = read\_data("uw", "99011116541W", full=true)}}}] \leavevmode\begin{itemize}
\item {} 
Read UW-format data file \sphinxcode{\sphinxupquote{99011116541W}}

\item {} 
Store full header information in \sphinxcode{\sphinxupquote{:misc}}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{read\_data!(S, "sac", "MSH80*.SAC")}}}] \leavevmode\begin{itemize}
\item {} 
Read SAC-format files matching string pattern \sphinxtitleref{MSH80*.SAC}

\item {} 
Read into existing SeisData object \sphinxcode{\sphinxupquote{S}}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{S = read\_data("win32", "20140927*.cnt", cf="20140927*ch", nx\_new=360000)}}}] \leavevmode\begin{itemize}
\item {} 
Read win32-format data files with names matching pattern \sphinxcode{\sphinxupquote{2014092709*.cnt}}

\item {} 
Use ASCII channel information filenames that match pattern \sphinxcode{\sphinxupquote{20140927*ch}}

\item {} 
Assign new channels an initial size of \sphinxcode{\sphinxupquote{nx\_new}} samples

\end{itemize}

\end{description}

\end{enumerate}


\subsection{Format Descriptions and Notes}
\label{\detokenize{src/Formats/fileformats:format-descriptions-and-notes}}
\sphinxhref{http://geows.ds.iris.edu/documents/GeoCSV.pdf}{GeoCSV}: an extension of “human-readable”, tabular file format Comma-
Separated Values (CSV).

\sphinxstylestrong{Lennartz ASCII}: ASCII output of Lennartz portable digitizers.

\sphinxhref{https://www.passcal.nmt.edu/content/seg-y-what-it-is}{PASSCAL}: A single-channel variant SEG Y format developed by PASSCAL/New
Mexico Tech and commonly used with PASSCAL field equipment. PASSCAL differs from
SEG Y in that PASSCAL format uses neither file headers nor extended textural
headers, and the number of samples per trace can exceed 32767.

\sphinxhref{https://www.fdsn.org/seed\_manual/SEEDManual\_V2.4.pdf}{SEED}: SEED stands for
Standard for the Exchange of Earthquake Data; used by the International
Federation of Digital Seismograph Networks (FDSN) as an omnibus seismic data
standard. mini-SEED is a data-only variant that uses only data blockettes
and allows longer data records.

\sphinxhref{https://ds.iris.edu/files/sac-manual/manual/file\_format.html}{SAC}: the
Seismic Analysis Code data format, originally developed for the eponymous
command-line interpreter. Widely used, and supported in virtually every
programming language.

\sphinxhref{http://wiki.seg.org/wiki/SEG\_Y}{SEG Y}: Society of Exploration Geophysicists
data format. Common in the energy industry, developed and maintained by the SEG.
Only SEG Y rev 0 and \sphinxhref{https://seg.org/Portals/0/SEG/News\%20and\%20Resources/Technical\%20Standards/seg\_y\_rev1.pdf}{rev 1}
with standard headers are supported.

\sphinxstylestrong{UW}: the University of Washington data format has no online reference and is
no longer in use. Created by the Pacific Northwest Seismic Network for event
archival; used through the early 2000s. A UW event is described by a pickfile
and a corresponding data file, whose names are identical except for the last
character; for example, the files 99062109485o and 99062109485W
describe event 99062109485. Unlike the win32 data format, the data file is
self-contained; the pick file is not required to use raw trace data. Only UW-2
data files are supported by SeisIO; we have never encountered a UW-1 data file
outside of Exabyte tapes and have no reason to suspect that any remain in
circulation.

\sphinxhref{http://eoc.eri.u-tokyo.ac.jp/WIN/Eindex.html}{Win32}: data format developed
by the NIED (National Research Institute for Earth Science and Disaster Prevention),
Japan.  Data are typically divided into files that contain a minute of continuous
data from several channels. Data within each file are stored by channel in
one-second segments as variable-precision delta-encoded integers. Channel
information is retrieved from an external channel information file. Although
accurate channel files are needed to use win32 data, these files are not strictly
controlled by any central authority and inconsistencies in channel parameters,
particularly gains, are known to exist.


\subsection{Other File I/O Functions}
\label{\detokenize{src/Formats/fileformats:other-file-i-o-functions}}\index{readuwevt() (built-in function)@\spxentry{readuwevt()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Formats/fileformats:readuwevt}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{readuwevt}}}{\emph{fpat}}{}
\end{fulllineitems}


Read University of Washington-format event data with file pattern stub fpat.
fstub can be a datafile name, a pickname, or a stub.
\index{rseis() (built-in function)@\spxentry{rseis()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Formats/fileformats:rseis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{rseis}}}{\emph{fname}}{}
\end{fulllineitems}


Read SeisIO native format data into an array of SeisIO structures.
\index{sachdr() (built-in function)@\spxentry{sachdr()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Formats/fileformats:sachdr}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sachdr}}}{\emph{fname}}{}
\end{fulllineitems}


Print headers from SAC file to stdout.
\index{segyhdr() (built-in function)@\spxentry{segyhdr()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Formats/fileformats:segyhdr}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{segyhdr}}}{\emph{fname}\sphinxoptional{, \emph{PASSCAL=true::Bool}}}{}
\end{fulllineitems}


Print headers from SEG Y file to stdout. Specify \sphinxcode{\sphinxupquote{passcal=true}} for PASSCAL SEG Y.
\index{uwdf() (built-in function)@\spxentry{uwdf()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Formats/fileformats:uwdf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{uwdf}}}{\emph{dfname}}{}
\end{fulllineitems}


Parse UW event data file \sphinxcode{\sphinxupquote{dfname}} into a new SeisEvent structure.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{uwpf!(evt,~pfname)}}}
\end{fulllineitems}


Parse UW event pick file into SeisEvent structure.
\index{uwpf() (built-in function)@\spxentry{uwpf()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Formats/fileformats:uwpf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{uwpf}}}{\emph{pfname}}{}
\end{fulllineitems}


Parse UW event pick file \sphinxcode{\sphinxupquote{pfname}} into a new SeisEvent structure.
\index{writesac() (built-in function)@\spxentry{writesac()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Formats/fileformats:writesac}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{writesac}}}{\emph{S}\sphinxoptional{, \emph{ts=true}}}{}
\end{fulllineitems}


Write SAC data to SAC files with auto-generated names. Specify ts=true to write
time stamps; this will flag the file as generic x-y data in the SAC interpreter.
\index{wseis() (built-in function)@\spxentry{wseis()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Formats/fileformats:wseis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{wseis}}}{\emph{fname}, \emph{S}}{}
\end{fulllineitems}

\index{wseis() (built-in function)@\spxentry{wseis()}\spxextra{built-in function}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{wseis}}}{\emph{fname}, \emph{S}, \emph{T}, \emph{U...}}{}
\end{fulllineitems}


Write SeisIO data to fname. Multiple objects can be written at once.


\chapter{Web}
\label{\detokenize{index:web}}

\section{Web Requests}
\label{\detokenize{src/Web/webclients:web-requests}}\label{\detokenize{src/Web/webclients:getdata}}\label{\detokenize{src/Web/webclients::doc}}
Data requests use \sphinxcode{\sphinxupquote{get\_data!}} for FDSN or IRIS data services; for (near)
real-time streaming, see {\hyperref[\detokenize{src/Web/seedlink:seedlink-section}]{\sphinxcrossref{\DUrole{std,std-ref}{SeedLink}}}}.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{get\_data!(S,~method,~channels;~KWs)}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{S~=~get\_data(method,~channels;~KWs)}}}
\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] Retrieve time-series data from a web archive to SeisData structure \sphinxstylestrong{S}.
\item[] 
\item[] \sphinxstylestrong{method}
\item[] \sphinxstylestrong{“IRIS”}: {\hyperref[\detokenize{src/Web/webclients:irisws}]{\sphinxcrossref{\DUrole{std,std-ref}{IRISWS}}}}.
\item[] \sphinxstylestrong{“FDSN”}: {\hyperref[\detokenize{src/Web/webclients:fdsnws}]{\sphinxcrossref{\DUrole{std,std-ref}{FDSNWS dataselect}}}}. Change FDSN servers with keyword \sphinxcode{\sphinxupquote{-{-}src}} using the {\hyperref[\detokenize{src/Appendices/web_syntax:servers}]{\sphinxcrossref{\DUrole{std,std-ref}{server list}}}} (also available by typing \sphinxcode{\sphinxupquote{?seis\_www}}).
\item[] 
\item[] \sphinxstylestrong{channels}
\item[] Channels to retrieve; can be passed as a {\hyperref[\detokenize{src/Appendices/web_syntax:cid}]{\sphinxcrossref{\DUrole{std,std-ref}{string, string array, or parameter file}}}}. Type \sphinxcode{\sphinxupquote{?chanspec}} at the Julia prompt for more info.
\item[] 
\item[] \sphinxstylestrong{KWs}
\item[] Keyword arguments; see also {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{SeisIO standard KWs}}}} or type \sphinxcode{\sphinxupquote{?SeisIO.KW}}.
\item[] Standard keywords: fmt, nd, opts, rad, reg, si, to, v, w, y
\item[] Other keywords:
\item[] \sphinxcode{\sphinxupquote{-{-}s}}: Start time
\item[] \sphinxcode{\sphinxupquote{-{-}t}}: Termination (end) time
\end{DUlineblock}


\subsection{Examples}
\label{\detokenize{src/Web/webclients:examples}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxcode{\sphinxupquote{get\_data!(S, "FDSN", "UW.SEP..EHZ,UW.SHW..EHZ,UW.HSR..EHZ", "IRIS", t=(-600))}}: using FDSNWS, get the last 10 minutes of data from three short-period vertical-component channels at Mt. St. Helens, USA.

\item {} 
\sphinxcode{\sphinxupquote{get\_data!(S, "IRIS", "CC.PALM..EHN", "IRIS", t=(-120), f="sacbl")}}: using IRISWS, fetch the last two minutes of data from component EHN, station PALM (Palmer Lift (Mt. Hood), OR, USA,), network CC (USGS Cascade Volcano Observatory, Vancouver, WA, USA), in bigendian SAC format, and merge into SeisData structure \sphinxtitleref{S}.

\item {} 
\sphinxcode{\sphinxupquote{get\_data!(S, "FDSN", "CC.TIMB..EHZ", "IRIS", t=(-600), w=true)}}: using FDSNWS, get the last 10 minutes of data from channel EHZ, station TIMB (Timberline Lodge, OR, USA), save the data directly to disk, and add it to SeisData structure \sphinxtitleref{S}.

\item {} 
\sphinxcode{\sphinxupquote{S = get\_data("FDSN", "HV.MOKD..HHZ", "IRIS", s="2012-01-01T00:00:00", t=(-3600))}}: using FDSNWS, fill a new SeisData structure \sphinxtitleref{S} with an hour of data ending at 2012-01-01, 00:00:00 UTC, from HV.MOKD..HHZ (USGS Hawai’i Volcano Observatory).

\end{enumerate}


\subsection{FDSN Queries}
\label{\detokenize{src/Web/webclients:fdsn-queries}}\phantomsection\label{\detokenize{src/Web/webclients:fdsnws}}
\sphinxhref{http://www.fdsn.org/}{The International Federation of Digital Seismograph Networks (FDSN)} is a global organization that supports seismology research. The FDSN web protocol offers near-real-time access to data from thousands of instruments across the world.

FDSN queries in SeisIO are highly customizable; see {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{data keywords list}}}} and {\hyperref[\detokenize{src/Appendices/web_syntax:cid}]{\sphinxcrossref{\DUrole{std,std-ref}{channel id syntax}}}}.


\subsubsection{Data Query}
\label{\detokenize{src/Web/webclients:data-query}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{get\_data!(S,~"FDSN",~channels;~KWs)}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{S~=~get\_data("FDSN",~channels;~KWs)}}}
\end{fulllineitems}


FDSN data query with get\_data! wrapper.

\begin{DUlineblock}{0em}
\item[] {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{Shared keywords}}}}: fmt, nd, opts, rad, reg, s, si, t, to, v, w, y
\item[] Other keywords:
\item[] \sphinxcode{\sphinxupquote{-{-}s}}: Start time
\item[] \sphinxcode{\sphinxupquote{-{-}t}}: Termination (end) time
\item[] \sphinxcode{\sphinxupquote{xf}}: Name of XML file to save station metadata
\end{DUlineblock}


\subsubsection{Station Query}
\label{\detokenize{src/Web/webclients:station-query}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{FDSNsta!(S,~chans,~KW)}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{S~=~FDSNsta(chans,~KW)}}}
\end{fulllineitems}


Fill channels \sphinxtitleref{chans} of SeisData structure \sphinxtitleref{S} with information retrieved from
remote station XML files by web query.

\begin{DUlineblock}{0em}
\item[] {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{Shared keywords}}}}: src, to, v
\item[] Other keywords:
\item[] \sphinxcode{\sphinxupquote{-{-}s}}: Start time
\item[] \sphinxcode{\sphinxupquote{-{-}t}}: Termination (end) time
\end{DUlineblock}


\subsubsection{Event Header Query}
\label{\detokenize{src/Web/webclients:event-header-query}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{H~=~FDSNevq(ot)}}}
\end{fulllineitems}


{\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{Shared keywords}}}}: evw, rad, reg, mag, nev, src, to, v, w

Multi-server query for the event(s) with origin time(s) closest to \sphinxtitleref{ot}. Returns
a SeisHdr.

Notes:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Specify \sphinxtitleref{ot} as a string formatted YYYY-MM-DDThh:mm:ss in UTC (e.g. “2001-02-08T18:54:32”). Returns a SeisHdr array.

\item {} 
Incomplete string queries are read to the nearest fully-specified time constraint; thus, \sphinxtitleref{FDSNevq(“2001-02-08”)} returns the nearest event to 2001-02-08T00:00:00.

\item {} 
If no event is found in the specified search window, FDSNevq exits with an error.

\end{enumerate}

\begin{DUlineblock}{0em}
\item[] {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{Shared keywords}}}}: evw, reg, mag, nev, src, to, w
\end{DUlineblock}


\subsubsection{Event Header and Data Query}
\label{\detokenize{src/Web/webclients:event-header-and-data-query}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{Ev~=~FDSNevt(ot::String,~chans::String)}}}
\end{fulllineitems}


Get trace data for the event closest to origin time \sphinxtitleref{ot} on channels \sphinxtitleref{chans}.
Returns a SeisEvent.

\begin{DUlineblock}{0em}
\item[] {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{Shared keywords}}}}: fmt, mag, nd, opts, pha, rad, reg, src, to, v, w
\item[] Other keywords:
\item[] \sphinxcode{\sphinxupquote{-{-}len}}: desired record length \sphinxstyleemphasis{in minutes}.
\end{DUlineblock}


\subsection{IRIS Queries}
\label{\detokenize{src/Web/webclients:iris-queries}}\phantomsection\label{\detokenize{src/Web/webclients:irisws}}
Incorporated Research Institutions for Seismology \sphinxhref{http://www.iris.edu/}{(IRIS)} is a consortium of universities dedicated to the operation of science facilities for the acquisition, management, and distribution of seismological data.


\subsubsection{Data Query Features}
\label{\detokenize{src/Web/webclients:data-query-features}}\begin{itemize}
\item {} 
Stage zero gains are removed from trace data; all IRIS data will appear to have a gain of 1.0.

\item {} 
IRISWS disallows wildcards in channel IDs.

\item {} 
Channel spec \sphinxstyleemphasis{must} include the net, sta, cha fields; thus, CHA = “CC.VALT..BHZ” is OK; CHA = “CC.VALT” is not.

\end{itemize}


\subsubsection{Phase Onset Query}
\label{\detokenize{src/Web/webclients:phase-onset-query}}
Command-line interface to IRIS online travel time calculator, which calls TauP {[}1-2{]}. Returns a matrix of strings.

Specify \(\Delta\) in decimal degrees, z in km with + = down.

\begin{DUlineblock}{0em}
\item[] Shared keywords keywords: pha, to, v
\item[] Other keywords:
\item[] \sphinxcode{\sphinxupquote{-model}}: velocity model (defaults to “iasp91”)
\end{DUlineblock}

\sphinxstylestrong{References}
\begin{itemize}
\item {} 
Crotwell, H. P., Owens, T. J., \& Ritsema, J. (1999). The TauP Toolkit: Flexible seismic travel-time and ray-path utilities, SRL 70(2), 154-160.

\item {} 
TauP manual: \sphinxurl{http://www.seis.sc.edu/downloads/TauP/taup.pdf}

\end{itemize}


\section{SeedLink}
\label{\detokenize{src/Web/seedlink:seedlink}}\label{\detokenize{src/Web/seedlink:seedlink-section}}\label{\detokenize{src/Web/seedlink::doc}}
\sphinxhref{https://www.seiscomp3.org/wiki/doc/applications/seedlink}{SeedLink} is a
TCP/IP-based data transmission protocol that allows near-real-time access to
data from thousands of geophysical monitoring instruments. See
{\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{data keywords list}}}} and {\hyperref[\detokenize{src/Appendices/web_syntax:cid}]{\sphinxcrossref{\DUrole{std,std-ref}{channel id syntax}}}} for options.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{SeedLink!(S,~chans,~KWs)}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{SeedLink!(S,~chans,~patts,~KWs)}}}
\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{S~=~SeedLink(chans,~KWs)}}}
\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{chans}
\item[] Channel specification can use any of the following options:
\item[] 
\item[] 1. A comma-separated String where each pattern follows the syntax NET.STA.LOC.CHA.DFLAG, e.g. UW.TDH..EHZ.D. Use “?” to match any single character.
\item[] 2. An Array\{String,1\} with one pattern per entry, following the above syntax.
\item[] 3. The name of a configuration text file, with one channel pattern per line; see {\hyperref[\detokenize{src/Appendices/web_syntax:ccfg}]{\sphinxcrossref{\DUrole{std,std-ref}{Channel Configuration File syntax}}}}.
\item[] 
\item[] \sphinxstylestrong{patts}
\item[] Data selection patterns. See official SeedLink documentation; syntax is identical.
\item[] 
\item[] \sphinxstylestrong{KWs}
\item[] Keyword arguments; see also {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{SeisIO standard KWs}}}} or type \sphinxcode{\sphinxupquote{?SeisIO.KW}}.
\item[] Standard keywords: fmt, opts, q, si, to, v, w, y
\item[] SL keywords: gap, kai, mode, port, refresh, safety, x\_on\_err
\item[] Other keywords:
\item[] \sphinxcode{\sphinxupquote{u}} specifies the URL without “\sphinxurl{http://}”
\end{DUlineblock}

Initiate a SeedLink session in DATA mode to feed data from channels \sphinxcode{\sphinxupquote{chans}} with
selection patterns \sphinxcode{\sphinxupquote{patts}} to SeisData structure \sphinxcode{\sphinxupquote{S}}. A handle to a TCP
connection is appended to \sphinxcode{\sphinxupquote{S.c}}.Data are periodically parsed until the
connection is closed. One SeisData object can support multiple connections,
provided that each connection’s streams feed unique channels.


\subsection{Special Rules}
\label{\detokenize{src/Web/seedlink:special-rules}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} \begin{description}
\item[{SeedLink follows unusual rules for wild cards in \sphinxcode{\sphinxupquote{sta}} and \sphinxcode{\sphinxupquote{patts}}:}] \leavevmode\begin{enumerate}
\def\theenumii{\alph{enumii}}
\def\labelenumii{\theenumii .}
\makeatletter\def\p@enumiii{\p@enumii \theenumii .}\makeatother
\item {} 
\sphinxcode{\sphinxupquote{*}} is not a valid SeedLink wild card.

\item {} 
The LOC and CHA fields can be left blank in \sphinxcode{\sphinxupquote{sta}} to select all locations and channels.

\end{enumerate}

\end{description}

\item {} \begin{description}
\item[{DO NOT feed one data channel with multiple SeedLink streams. This can have severe consequences:}] \leavevmode\begin{enumerate}
\def\theenumii{\alph{enumii}}
\def\labelenumii{\theenumii .}
\makeatletter\def\p@enumiii{\p@enumii \theenumii .}\makeatother
\item {} 
A channel fed by multiple live streams will have many small time sequences out of order. \sphinxcode{\sphinxupquote{merge!}} is not guaranteed to fix it.

\item {} 
SeedLink will almost certainly crash.

\item {} 
Your data may be corrupted.

\item {} 
The Julia interpreter can freeze, requiring \sphinxcode{\sphinxupquote{kill -9}} on the process.

\item {} 
This is not an “issue”. There will never be a workaround. It’s what happens when one intentionally causes TCP congestion on one’s own machine while writing to open data streams in memory. Hint: don’t do this.

\end{enumerate}

\end{description}

\end{enumerate}


\subsection{Special Methods}
\label{\detokenize{src/Web/seedlink:special-methods}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{close(S.c{[}i{]})}} ends SeedLink connection \sphinxcode{\sphinxupquote{i}}.

\item {} 
\sphinxcode{\sphinxupquote{!deleteat(S.c, i)}} removes a handle to closed SeedLink connection \sphinxcode{\sphinxupquote{i}}.

\end{itemize}


\subsubsection{SeedLink Utilities}
\label{\detokenize{src/Web/seedlink:seedlink-utilities}}\index{SL\_info() (built-in function)@\spxentry{SL\_info()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Web/seedlink:SL_info}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SL\_info}}}{\emph{v}, \emph{url}}{}
\end{fulllineitems}


Retrieve SeedLink information at verbosity level \sphinxstylestrong{v} from \sphinxstylestrong{url}. Returns XML as a string. Valid strings for \sphinxstylestrong{L} are ID, CAPABILITIES, STATIONS, STREAMS, GAPS, CONNECTIONS, ALL.
\index{has\_sta() (built-in function)@\spxentry{has\_sta()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Web/seedlink:has_sta}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{has\_sta}}}{\emph{sta}\sphinxoptional{, \emph{u=url}, \emph{port=n}}}{}
\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] SL keywords: gap, port
\item[] Other keywords: \sphinxcode{\sphinxupquote{u}} specifies the URL without “\sphinxurl{http://}”
\end{DUlineblock}

Check that streams exist at \sphinxtitleref{url} for stations \sphinxtitleref{sta}, formatted
NET.STA. Use “?” to match any single character. Returns true for
stations that exist. \sphinxtitleref{sta} can also be the name of a valid config
file or a 1d string array.

Returns a BitArray with one value per entry in \sphinxtitleref{sta.}
\index{has\_stream() (built-in function)@\spxentry{has\_stream()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Web/seedlink:has_stream}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{has\_stream}}}{\emph{cha::Union\{String}, \emph{Array\{String}, \emph{1\}\}}, \emph{u::String}}{}
\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] SL keywords: gap, port
\item[] Other keywords: \sphinxcode{\sphinxupquote{u}} specifies the URL without “\sphinxurl{http://}”
\end{DUlineblock}

Check that streams with recent data exist at url \sphinxtitleref{u} for channel spec
\sphinxtitleref{cha}, formatted NET.STA.LOC.CHA.DFLAG, e.g. “UW.TDH..EHZ.D,
CC.HOOD..BH?.E”. Use “?” to match any single character. Returns \sphinxtitleref{true}
for streams with recent data.

\sphinxtitleref{cha} can also be the name of a valid config file.


\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{has\_stream}}}{\emph{sta::Array\{String}, \emph{1\}}, \emph{sel::Array\{String}, \emph{1\}}, \emph{u::String}, \emph{port=N::Int}, \emph{gap=G::Real}}{}
\end{fulllineitems}


\begin{DUlineblock}{0em}
\item[] SL keywords: gap, port
\item[] Other keywords: \sphinxcode{\sphinxupquote{u}} specifies the URL without “\sphinxurl{http://}”
\end{DUlineblock}

If two arrays are passed to has\_stream, the first should be
formatted as SeedLink STATION patterns (formated “SSSSS NN”, e.g.
{[}“TDH UW”, “VALT CC”{]}); the second be an array of SeedLink selector
patterns (formatted LLCCC.D, e.g. {[}“??EHZ.D”, “??BH?.?”{]}).


\chapter{Processing}
\label{\detokenize{index:processing}}

\section{Data Processing Functions}
\label{\detokenize{src/Processing/processing:data-processing-functions}}\label{\detokenize{src/Processing/processing::doc}}
Supported processing operations are described below. Functions are organized
categorically.

In most cases, a “safe” version of each function can be invoked to create a
new SeisData object with the processed output.

Any function that can logically operate on a SeisChannel object will do so. Any
function that operates on a SeisData object will also operate on a SeisEvent
object by applying itself to the SeisData object in the \sphinxcode{\sphinxupquote{:data}} field.


\subsection{Signal Processing}
\label{\detokenize{src/Processing/processing:signal-processing}}
Remove the mean from all channels i with S.fs{[}i{]} \textgreater{} 0.0. Specify irr=true to also
remove the mean from irregularly sampled channels. Ignores NaNs.

Remove the polynomial trend of degree n from every regularly-sampled channel i
in S using a least-squares polynomial fit. Ignores NaNs.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{equalize\_resp!(S,~resp\_new::Array{[},~hc\_new=HC,~C=CH{]})}}}
\end{fulllineitems}


Translate all data in SeisData structure \sphinxstylestrong{S} to instrument response \sphinxstylestrong{resp\_new}.
Expected structure of \sphinxstylestrong{resp\_new} is a complex Float64 2d array with zeros in
\sphinxstylestrong{resp{[}:,1{]}}, poles in \sphinxstylestrong{resp{[}:,2{]}}. If channel \sphinxstylestrong{i} has key \sphinxstylestrong{S.misc{[}i{]}{[}“hc”{]}},
the corresponding value is used as the critical damping constant; otherwise a
value of 1.0 is assumed.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{filtfilt!(S::SeisData{[};~KWs{]})}}}
\end{fulllineitems}


Apply a zero-phase filter to data in \sphinxstylestrong{S.x}.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{filtfilt!(Ev::SeisEvent{[};~KWs{]})}}}
\end{fulllineitems}


Apply zero-phase filter to \sphinxstylestrong{Ev.data.x}.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{filtfilt!(C::SeisChannel{[};~KWs{]})}}}
\end{fulllineitems}


Apply zero-phase filter to \sphinxstylestrong{C.x}

Filtering is applied to each contiguous data segment of each channel separately.

\#\#\# Keywords
Keywords control filtering behavior; specify e.g. filtfilt!(S, fl=0.1, np=2, rt=”Lowpass”).
Default values can be changed by adjustin the {\hyperref[\detokenize{src/Appendices/keywords:dkw}]{\sphinxcrossref{\DUrole{std,std-ref}{shared keywords}}}}, e.g.,
SeisIO.KW.Filt.np = 2 changes the default number of poles to 2.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{8}|\X{2}{8}|\X{1}{8}|\X{4}{8}|}
\hline
\sphinxstyletheadfamily 
KW
&\sphinxstyletheadfamily 
Default
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
\\
\hline
fl
&
1.0
&
Float64
&
lower corner frequency {[}Hz{]} $^{\text{(a)}}$
\\
\hline
fh
&
15.0
&
Float64
&
upper corner frequency {[}Hz{]} $^{\text{(a)}}$
\\
\hline
np
&
4
&
Int64
&
number of poles
\\
\hline
rp
&
10
&
Int64
&
pass-band ripple (dB)
\\
\hline
rs
&
30
&
Int64
&
stop-band ripple (dB)
\\
\hline
rt
&
“Bandpass”
&
String
&
response type (type of filter)
\\
\hline
dm
&
“Butterworth”
&
String
&
design mode (name of filter)
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

$^{\text{(a)}}$  By convention, the lower corner frequency (fl) is used in a Highpass
filter, and fh is used in a Lowpass filter.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{taper!(S)}}}
\end{fulllineitems}


Cosine taper each channel in S around time gaps.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{unscale!(S{[},~irr=false{]})}}}
\end{fulllineitems}


Divide the gains from all channels \sphinxstylestrong{i} with \sphinxstylestrong{S.fs{[}i{]} \textgreater{} 0.0}. Specify \sphinxstylestrong{irr=true} to
also remove gains of irregularly-sampled channels.


\subsection{Merge}
\label{\detokenize{src/Processing/processing:merge}}\label{\detokenize{src/Processing/processing:id1}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{merge!(S::SeisData,~U::SeisData)}}}
\end{fulllineitems}


Merge two SeisData structures. For timeseries data, a single-pass merge-and-prune
operation is applied to value pairs whose sample times are separated by less than
half the sampling interval.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{merge!(S::SeisData)}}}
\end{fulllineitems}


“Flatten” a SeisData structure by merging data from identical channels.


\subsubsection{Merge Behavior}
\label{\detokenize{src/Processing/processing:merge-behavior}}

\paragraph{Which channels merge?}
\label{\detokenize{src/Processing/processing:which-channels-merge}}\begin{itemize}
\item {} 
Channels merge if they have identical values for \sphinxcode{\sphinxupquote{:id}}, \sphinxcode{\sphinxupquote{:fs}}, \sphinxcode{\sphinxupquote{:loc}}, \sphinxcode{\sphinxupquote{:resp}}, and \sphinxcode{\sphinxupquote{:units}}.

\item {} 
An unset \sphinxcode{\sphinxupquote{:loc}}, \sphinxcode{\sphinxupquote{:resp}}, or \sphinxcode{\sphinxupquote{:units}} field matches any set value in the corresponding field of another channel.

\end{itemize}


\paragraph{What happens to merged fields?}
\label{\detokenize{src/Processing/processing:what-happens-to-merged-fields}}\begin{itemize}
\item {} 
The essential properties above are preserved.

\item {} 
Other fields are combined.

\item {} 
Merged channels with different \sphinxtitleref{:name} values use the name of the channel with the latest data before the merge; other names are logged to \sphinxtitleref{:notes}.

\end{itemize}


\paragraph{What does \sphinxstyleliteralintitle{\sphinxupquote{merge!}} resolve?}
\label{\detokenize{src/Processing/processing:what-does-merge-resolve}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{1}{2}|\X{1}{2}|}
\hline
\sphinxstyletheadfamily 
Issue
&\sphinxstyletheadfamily 
Resolution
\\
\hline
Empty channels
&
Delete
\\
\hline
Duplicated channels
&
Delete duplicate channels
\\
\hline
Duplicated windows in channel(s)
&
Delete duplicate windows
\\
\hline
Multiple channels, same properties$^{\text{(a)}}$
&
Merge to a single channel
\\
\hline
Channel with out-of-order time windows
&
Sort in chronological order
\\
\hline
Overlapping windows, identical data, time-aligned
&
Windows merged
\\
\hline
Overlapping windows, identical data, small time offset$^{\text{(a)}}$
&
Time offset corrected, windows merged
\\
\hline
Overlapping windows, non-identical data
&
Samples averaged, windows merged
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

$^{\text{(a)}}$ “Properties” here are \sphinxcode{\sphinxupquote{:id}}, \sphinxcode{\sphinxupquote{:fs}}, \sphinxcode{\sphinxupquote{:loc}}, \sphinxcode{\sphinxupquote{:resp}}, and \sphinxcode{\sphinxupquote{:units}}.
$^{\text{(b)}}$ Data offset \textgreater{}4 sample intervals are treated as overlapping and non-identical.


\paragraph{When SeisIO Won’t Merge}
\label{\detokenize{src/Processing/processing:when-seisio-won-t-merge}}
SeisIO does \sphinxstylestrong{not} combine data channels if \sphinxstylestrong{any} of the five fields above
are non-empty and different. For example, if a SeisData object S contains two
channels, each with id “XX.FOO..BHZ”, but one has fs=100 Hz and the other fs=50 Hz,
\sphinxstylestrong{merge!} does nothing.

It’s best to merge only unprocessed data. Data segments that were processed
independently (e.g. detrended) will be averaged pointwise when merged, which
can easily leave data in an unusuable state.


\subsection{Synchronize}
\label{\detokenize{src/Processing/processing:synchronize}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{sync!(S::SeisData)}}}
\end{fulllineitems}


Synchronize the start times of all data in S to begin at or after the last
start time in S.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{sync!(S::SeisData{[},~s=ST,~t=EN,~v=VV{]})}}}
\end{fulllineitems}


Synchronize all data in S to start at \sphinxtitleref{ST} and terminate at \sphinxtitleref{EN} with verbosity level VV.

For regularly-sampled channels, gaps between the specified and true times
are filled with the mean; this isn’t possible with irregularly-sampled data.
\begin{itemize}
\item {} 
s=”last”: (Default) sync to the last start time of any channel in \sphinxtitleref{S}.

\item {} 
s=”first”: sync to the first start time of any channel in \sphinxtitleref{S}.

\item {} 
A numeric value is treated as an epoch time (\sphinxtitleref{?time} for details).

\item {} 
A DateTime is treated as a DateTime. (see Dates.DateTime for details.)

\item {} 
Any string other than “last” or “first” is parsed as a DateTime.

\end{itemize}
\begin{itemize}
\item {} 
t=”none”: (Default) end times are not synchronized.

\item {} 
t=”last”: synchronize all channels to end at the last end time in \sphinxtitleref{S}.

\item {} 
t=”first” synchronize to the first end time in \sphinxtitleref{S}.

\item {} 
numeric, datetime, and non-reserved strings are treated as for \sphinxtitleref{-s}.

\end{itemize}


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{mseis!(S::SeisData,~U::SeisData,~...)}}}
\end{fulllineitems}


Merge multiple SeisData structures into S.


\subsection{Other Processing Functions}
\label{\detokenize{src/Processing/processing:other-processing-functions}}

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{nanfill!(S)}}}
\end{fulllineitems}


For each channel \sphinxstylestrong{i} in \sphinxstylestrong{S}, replace all NaNs in \sphinxstylestrong{S.x{[}i{]}} with the mean
of non-NaN values.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{ungap!(S{[},~m=true{]})}}}
\end{fulllineitems}


For each channel \sphinxstylestrong{i} in \sphinxstylestrong{S}, fill time gaps in \sphinxstylestrong{S.t{[}i{]}} with the mean of
non-NAN data in \sphinxstylestrong{S.x{[}i{]}}. If \sphinxstylestrong{m=false}, gaps are filled with NANs.


\chapter{Appendices}
\label{\detokenize{index:appendices}}

\section{Utility Functions}
\label{\detokenize{src/Appendices/function_list:utility-functions}}\label{\detokenize{src/Appendices/function_list:function-list}}\label{\detokenize{src/Appendices/function_list::doc}}
This appendix covers utility functions that belong in no other category.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{distaz!(Ev::SeisEvent)}}}
\end{fulllineitems}


Fill Ev with great-circle distance, azimuth, and back-azimuth for each channel. Writes to evt.data.misc.
\index{d2u() (built-in function)@\spxentry{d2u()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:d2u}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{d2u}}}{\emph{DT::DateTime}}{}
\end{fulllineitems}


Aliased to \sphinxcode{\sphinxupquote{Dates.datetime2unix}}.

Keyword \sphinxcode{\sphinxupquote{hc\_new}} specifies the new critical damping constant. Keyword \sphinxcode{\sphinxupquote{C}} specifies an array of channel numbers on which to operate; by default, every channel with fs \textgreater{} 0.0 is affected.
\index{fctopz() (built-in function)@\spxentry{fctopz()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:fctopz}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fctopz}}}{\emph{fc}}{}
\end{fulllineitems}


Convert critical frequency \sphinxcode{\sphinxupquote{fc}} to a matrix of complex poles and zeros; zeros in \sphinxcode{\sphinxupquote{resp{[}:,1{]}}}, poles in \sphinxcode{\sphinxupquote{resp{[}:,2{]}}}.
\index{find\_regex() (built-in function)@\spxentry{find\_regex()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:find_regex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{find\_regex}}}{\emph{path::String}, \emph{r::Regex}}{}
\end{fulllineitems}


OS-agnostic equivalent to Linux \sphinxtitleref{find}. First argument is a path string, second is a Regex. File strings are postprocessed using Julia’s native PCRE Regex engine. By design, \sphinxtitleref{find\_regex} only returns file names.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{(dist,~az,~baz)~=~gcdist({[}lat\_src,~lon\_src{]},~rec)}}}
\end{fulllineitems}


Compute great circle distance, azimuth, and backazimuth from source coordinates \sphinxcode{\sphinxupquote{{[}lat\_src, lon\_src{]}}} to receiver coordinates in \sphinxcode{\sphinxupquote{rec}} using the Haversine formula. \sphinxcode{\sphinxupquote{rec}} must be a two-column matix arranged {[}lat lon{]}. Returns a tuple of arrays.
\index{getbandcode() (built-in function)@\spxentry{getbandcode()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:getbandcode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{getbandcode}}}{\emph{fs}, \emph{fc=FC}}{}
\end{fulllineitems}


Get SEED-compliant one-character band code corresponding to instrument sample rate \sphinxcode{\sphinxupquote{fs}} and corner frequency \sphinxcode{\sphinxupquote{FC}}. If unset, \sphinxcode{\sphinxupquote{FC}} is assumed to be 1 Hz.
\index{ls() (built-in function)@\spxentry{ls()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:ls}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ls}}}{\emph{s::String}}{}
\end{fulllineitems}


Similar functionality to Bash ls with OS-agnostic output. Accepts wildcards in paths and file names.
* Always returns the full path and file name.
* Partial file name wildcards (e.g. “\sphinxtitleref{ls(data/2006*.sac)}) invoke \sphinxtitleref{glob}.
* Path wildcards (e.g. \sphinxtitleref{ls(/data/*/*.sac)}) invoke \sphinxtitleref{find\_regex} to circumvent glob limitations.
* Passing ony “*” as a filename (e.g. “\sphinxtitleref{ls(/home/*)}) invokes \sphinxtitleref{find\_regex} to recursively search subdirectories, as in the Bash shell.
\index{ls() (built-in function)@\spxentry{ls()}\spxextra{built-in function}}

\begin{fulllineitems}
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ls}}}{}{}
\end{fulllineitems}


Return full path and file name of files in current working directory.
\index{j2md() (built-in function)@\spxentry{j2md()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:j2md}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{j2md}}}{\emph{y}, \emph{j}}{}
\end{fulllineitems}


Convert Julian day \sphinxstylestrong{j} of year \sphinxstylestrong{y} to month, day.
\index{md2j() (built-in function)@\spxentry{md2j()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:md2j}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{md2j}}}{\emph{y}, \emph{m}, \emph{d}}{}
\end{fulllineitems}


Convert month \sphinxstylestrong{m}, day \sphinxstylestrong{d} of year \sphinxstylestrong{y} to Julian day \sphinxstylestrong{j}.

Remove unwanted characters from S.
\index{parsetimewin() (built-in function)@\spxentry{parsetimewin()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:parsetimewin}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parsetimewin}}}{\emph{s}, \emph{t}}{}
\end{fulllineitems}


Convert times \sphinxstylestrong{s} and \sphinxstylestrong{t} to strings \(\alpha\), \(\omega\) sorted \(\alpha\) \textless{} \(\omega\).
\sphinxstylestrong{s} and \sphinxstylestrong{t} can be real numbers, DateTime objects, or ASCII strings.
Expected string format is “yyyy-mm-ddTHH:MM:SS.nnn”, e.g. 2016-03-23T11:17:00.333.

“Safe” synchronize of start and end times of all trace data in SeisData structure \sphinxcode{\sphinxupquote{S}} to a new structure \sphinxcode{\sphinxupquote{U}}.
\index{u2d() (built-in function)@\spxentry{u2d()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:u2d}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{u2d}}}{\emph{x}}{}
\end{fulllineitems}


Alias to \sphinxcode{\sphinxupquote{Dates.unix2datetime}}.

function:: w\_time(W::Array\{Int64,2\}, fs::Float64)

Convert matrix W from time windows (w{[}:,1{]}:w{[}:,2{]}) in integer \(\mu\)s from the Unix epoch (1970-01-01T00:00:00) to sparse delta-encoded time representation. Specify fs in Hz.


\subsection{RandSeis}
\label{\detokenize{src/Appendices/function_list:randseis}}
This submodule is used to quickly generate SeisIO structures with quasi-random
field contents. Access it by typing “using SeisIO.RandSeis”
\begin{itemize}
\item {} 
Channels have SEED-compliant IDs, sampling frequencies, and data types.

\item {} 
Channel data are randomly generated.

\item {} 
Some time gaps are automatically inserted into regularly-sampled data.

\item {} 
Instrument location parameters are randomly set.

\end{itemize}


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{C~=~randSeisChannel({[},c=false,~s=false{]})}}}
\end{fulllineitems}


Generate a SeisChannel of random data. Specify c=true for campaign-style (irregularly-sampled) data (fs = 0.0); specify s=true to guarantee seismic data. s=true overrides c=true.

Generate 8 to 24 channels of random seismic data as a SeisData object.
\begin{itemize}
\item {} 
100*c\% of channels \sphinxstyleemphasis{after the first} will have irregularly-sampled data (fs = 0.0)

\item {} 
100*s\% of channels \sphinxstyleemphasis{after the first} are guaranteed to have seismic data.

randSeisData(N{[}, c=0.2, s=0.6{]})

\end{itemize}

Generate N channels of random seismic data as a SeisData object.
\index{randSeisEvent() (built-in function)@\spxentry{randSeisEvent()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/function_list:randSeisEvent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{randSeisEvent}}}{\sphinxoptional{\emph{c=0.2}, \emph{s=0.6}}}{}
\end{fulllineitems}


Generate a SeisEvent structure filled with random values.
* 100*c\% of channels \sphinxstyleemphasis{after the first} will have irregularly-sampled data (fs = 0.0)
* 100*s\% of channels \sphinxstyleemphasis{after the first} are guaranteed to have seismic data.


\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{H~=~randSeisHdr()}}}
\end{fulllineitems}


Generate a SeisHdr structure filled with random values.


\section{Structure and Field Descriptions}
\label{\detokenize{src/Appendices/seisdata_fields:structure-and-field-descriptions}}\label{\detokenize{src/Appendices/seisdata_fields::doc}}

\subsection{SeisChannel Fields}
\label{\detokenize{src/Appendices/seisdata_fields:seischannel-fields}}\label{\detokenize{src/Appendices/seisdata_fields:sdf}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Meaning
\\
\hline
id
&
String
&
unique channel ID formatted
{\hyperref[\detokenize{src/Appendices/web_syntax:cid}]{\sphinxcrossref{\DUrole{std,std-ref}{net.sta.loc.cha}}}}
\\
\hline
name
&
String
&
freeform channel name string
\\
\hline
src
&
String
&
description of data source
\\
\hline
units
&
String
&
units of dependent variable %
\begin{footnote}[1]\sphinxAtStartFootnote
Use \sphinxhref{http://unitsofmeasure.org/trac}{UCUM-compliant abbreviations} wherever possible.
%
\end{footnote}
\\
\hline
fs
&
Float64
&
sampling frequency in Hz
\\
\hline
gain
&
Float64
&
scalar to convert x to SI units in
flat part of power spectrum %
\begin{footnote}[2]\sphinxAtStartFootnote
Gain has an identical meaning to the “Stage 0 gain” of FDSN XML.
%
\end{footnote}
\\
\hline
loc
&
Array\{Float64,1\}
&
sensor location: {[}lat, lon, ele, az,
inc{]} %
\begin{footnote}[3]\sphinxAtStartFootnote
Azimuth is measured clockwise from North; incidence of 0° = vertical; both use degrees.
%
\end{footnote}
\\
\hline
resp
&
Array\{Complex
\{Float64\},2\}
&
complex instrument response %
\begin{footnote}[4]\sphinxAtStartFootnote
Zeros in \sphinxcode{\sphinxupquote{:resp{[}i{]}{[}:,1{]}}}, poles in \sphinxcode{\sphinxupquote{:resp{[}i{]}{[}:,2{]}}}.
%
\end{footnote}
\\
\hline
misc
&
Dict\{String,Any\}
&
miscellaneous information %
\begin{footnote}[5]\sphinxAtStartFootnote
Arrays in \sphinxcode{\sphinxupquote{:misc}} should each contain a single Type (e.g. Array\{Float64,1\}, never Array\{Any,1\}). See the {\hyperref[\detokenize{src/Appendices/seisdata_fileformat:smt}]{\sphinxcrossref{\DUrole{std,std-ref}{SeisIO file format description}}}} for a full list of allowed value types in :misc.
%
\end{footnote}
\\
\hline
notes
&
Array\{String,1\}
&
timestamped notes
\\
\hline
t
&
Array\{Int64,2\}
&
time gaps
{\hyperref[\detokenize{src/Appendices/seisdata_fields:seisdata-t}]{\sphinxcrossref{\DUrole{std,std-ref}{(see below)}}}}
\\
\hline
x
&
Array\{Float64,1\}
&
univariate data
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Table Footnotes}


\subsection{SeisData Fields}
\label{\detokenize{src/Appendices/seisdata_fields:seisdata-fields}}
As SeisChannel, plus


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Meaning
\\
\hline
n
&
Int64
&
number of channels
\\
\hline
c
&
Array\{TCPSocket,1\}
&
array of TCP connections
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Time Convention}
\label{\detokenize{src/Appendices/seisdata_fields:time-convention}}\phantomsection\label{\detokenize{src/Appendices/seisdata_fields:seisdata-t}}
The units of \sphinxcode{\sphinxupquote{t}} are \sphinxstyleemphasis{integer microseconds}, measured from Unix epoch time
(1970-01-01T00:00:00.000).

For \sphinxstyleemphasis{regularly sampled} data (\sphinxcode{\sphinxupquote{fs \textgreater{} 0.0}}), each \sphinxcode{\sphinxupquote{t}} is a sparse
delta-compressed representation of \sphinxstyleemphasis{time gaps} in the corresponding \sphinxcode{\sphinxupquote{x}}.
The first column stores indices of gaps; the second, gap lengths.

Within each time field, \sphinxcode{\sphinxupquote{t{[}1,2{]}}} stores the time of the first sample of the
corresponding \sphinxcode{\sphinxupquote{x}}. The last row of each \sphinxcode{\sphinxupquote{t}} should always take the form {}`
\sphinxtitleref{{[}length(x) 0{]}{}`}. Other rows take the form \sphinxcode{\sphinxupquote{{[}(starting index of gap) (length of gap){]}}}.

For \sphinxstyleemphasis{irregularly sampled data} (\sphinxcode{\sphinxupquote{fs = 0}}), \sphinxcode{\sphinxupquote{t{[}:,2{]}}} is a dense
representation of \sphinxstyleemphasis{time stamps for each sample}.


\subsection{SeisHdr Fields}
\label{\detokenize{src/Appendices/seisdata_fields:seishdr-fields}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Meaning
\\
\hline
id
&
Int64
&
numeric event ID
\\
\hline
ot
&
DateTime
&
origin time
\\
\hline
loc
&
Array\{Float64, 1\}
&
hypocenter
\\
\hline
mag
&
Tuple\{Float32, String\}
&
magnitude, scale
\\
\hline
int
&
Tuple\{UInt8, String\}
&
intensity, scale
\\
\hline
mt
&
Array\{Float64, 1\}
&
moment tensor: (1-6) tensor,
(7) scalar moment, (8) \%dc
\\
\hline
np
&
Array\{Tuple\{Float64,
Float64, Float64\},1\}
&
nodal planes
\\
\hline
pax
&
Array\{Tuple\{Float64,
Float64, Float64\},1\}
&
principal axes, ordered P, T, N
\\
\hline
src
&
String
&
data source (e.g. url/filename)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{SeisEvent Fields}
\label{\detokenize{src/Appendices/seisdata_fields:seisevent-fields}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Name
&\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Meaning
\\
\hline
hdr
&
SeisHdr
&
event header
\\
\hline
data
&
SeisData
&
event data
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{SeisIO File Format}
\label{\detokenize{src/Appendices/seisdata_fileformat:seisio-file-format}}\label{\detokenize{src/Appendices/seisdata_fileformat:seisdata-file-format}}\label{\detokenize{src/Appendices/seisdata_fileformat::doc}}
Files are written in little-endian byte order.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Abbreviations used in this section}\label{\detokenize{src/Appendices/seisdata_fileformat:id1}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{3}{25}|\X{10}{25}|\X{5}{25}|\X{7}{25}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Meaning
&\sphinxstyletheadfamily 
Julia
&\sphinxstyletheadfamily 
C \sphinxcode{\sphinxupquote{\textless{}stdint.h\textgreater{}}}
\\
\hline
c
&
unsigned 8-bit character
&
Char
&
unsigned char
\\
\hline
f32
&
32-bit float
&
Float32
&
float
\\
\hline
f64
&
64-bit float
&
Float64
&
double
\\
\hline
i64
&
signed 64-bit integer
&
Int64
&
int64\_t
\\
\hline
u8
&
unsigned 8-bit int
&
UInt8
&
uint8\_t
\\
\hline
u32
&
unsigned 32-bit int
&
UInt32
&
int32\_t
\\
\hline
u64
&
unsigned 64-bit int
&
UInt64
&
uint64\_t
\\
\hline
u(8)
&
unsigned 8-bit integer
&
UInt8
&
uint8\_t
\\
\hline
i(8)
&
signed 8-bit integer
&
Int8
&
int8\_t
\\
\hline
f(8)
&
8-bit float
&
Float8
&
float or double
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{File header}
\label{\detokenize{src/Appendices/seisdata_fileformat:file-header}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{File header (14 bytes + TOC)}\label{\detokenize{src/Appendices/seisdata_fileformat:id2}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{5}{47}|\X{32}{47}|\X{5}{47}|\X{5}{47}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Meaning
&\sphinxstyletheadfamily 
T
&\sphinxstyletheadfamily 
N
\\
\hline&
“SEISIO”
&
c
&
6
\\
\hline
\sphinxcode{\sphinxupquote{V}}
&
SeisIO version
&
f32
&
1
\\
\hline
\sphinxcode{\sphinxupquote{jv}}
&
Julia version
&
f32
&
1
\\
\hline
\sphinxcode{\sphinxupquote{J}}
&
\# of SeisIO objects in file
&
u32
&
1
\\
\hline
\sphinxcode{\sphinxupquote{C}}
&
Character codes for each object
&
c
&
J
\\
\hline
\sphinxcode{\sphinxupquote{B}}
&
Byte indices for each object
&
u64
&
J
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

The Julia version stores VERSION.major.VERSION.minor as a Float32, e.g. v0.5 is stored as 0.5f0; SeisIO version is stored similarly.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Object codes}\label{\detokenize{src/Appendices/seisdata_fileformat:id3}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{5}{30}|\X{25}{30}|}
\hline
\sphinxstyletheadfamily 
Char
&\sphinxstyletheadfamily 
Meaning
\\
\hline
‘D’
&
SeisData
\\
\hline
‘H’
&
SeisHdr
\\
\hline
‘E’
&
SeisEvent
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{SeisHdr}
\label{\detokenize{src/Appendices/seisdata_fileformat:seishdr}}
Structural overview:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Int64\PYGZus{}vals}
\PYG{p}{:}\PYG{n}{mag}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}       \PYG{c+c1}{\PYGZsh{} Float32}
\PYG{n}{Float64\PYGZus{}vals}
\PYG{n}{UInt8\PYGZus{}vals}
\PYG{p}{:}\PYG{n}{misc}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Int64 values}\label{\detokenize{src/Appendices/seisdata_fileformat:id4}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{1}{5}|\X{4}{5}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Meaning
\\
\hline
id
&
event id
\\
\hline
ot
&
origin time in integer \(\mu\)s from Unix epoch
\\
\hline
L\_int
&
length of intensity scale string
\\
\hline
L\_src
&
length of src string
\\
\hline
L\_notes
&
length of notes string
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

Magnitude is stored as a Float32 after the Int64 values.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Float64 values}\label{\detokenize{src/Appendices/seisdata_fileformat:id5}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{1}{10}|\X{1}{10}|\X{8}{10}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
loc
&
3
&
lat, lon, dep
\\
\hline
mt
&
8
&
tensor, scalar moment, \%dc
\\
\hline
np
&
6
&
np (nodal planes: 1st, 2nd)
\\
\hline
pax
&
9
&
pax (principal axes: P, T, N)
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{UInt8 values}\label{\detokenize{src/Appendices/seisdata_fileformat:id6}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{1}{6}|\X{1}{6}|\X{4}{6}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
msc
&
2
&
magnitude scale characters
\\
\hline
c
&
1
&
separator for notes
\\
\hline
i
&
1
&
intensity value
\\
\hline
i\_sc
&
L\_int
&
intensity scale string
\\
\hline
src
&
L\_src
&
\sphinxcode{\sphinxupquote{:src}} as a string
\\
\hline
notes
&
L\_notes
&
\sphinxcode{\sphinxupquote{:notes}} joined a string with delimiter \sphinxcode{\sphinxupquote{c}}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

Entries in Misc are stored after UInt8 values. See below for details.


\subsection{SeisData}
\label{\detokenize{src/Appendices/seisdata_fileformat:seisdata}}
Structural overview:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S}\PYG{o}{.}\PYG{n}{n}           \PYG{c+c1}{\PYGZsh{} UInt32}
\PYG{c+c1}{\PYGZsh{} Repeated for each channel}
\PYG{n}{Int64\PYGZus{}vals}
\PYG{n}{Float64\PYGZus{}vals}
\PYG{n}{UInt8\PYGZus{}vals}    \PYG{c+c1}{\PYGZsh{} including compressed S.x}
\PYG{p}{:}\PYG{n}{misc}
\end{sphinxVerbatim}

S.x is compressed with BloscLZ before writing to disk.


\subsubsection{Channel data}
\label{\detokenize{src/Appendices/seisdata_fileformat:channel-data}}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Int64 values}\label{\detokenize{src/Appendices/seisdata_fileformat:id7}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{1}{13}|\X{2}{13}|\X{10}{13}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
L\_t
&&
length(S.t)
\\
\hline
r
&&
length(S.resp)
\\
\hline
L\_units
&&
length(S.units)
\\
\hline
L\_src
&&
length(S.src)
\\
\hline
L\_name
&&
length(S.name)
\\
\hline
L\_notes
&&
length of notes string
\\
\hline
lxc
&&
length of BloscLZ-compressed S.x
\\
\hline
L\_x
&&
length(S.x)
\\
\hline
t
&
L\_t
&
S.t
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Float64 values}\label{\detokenize{src/Appendices/seisdata_fileformat:id8}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{1}{11}|\X{2}{11}|\X{8}{11}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
fs
&
1
&
S.fs
\\
\hline
gain
&
1
&
S.gain
\\
\hline
loc
&
5
&
S.loc (lat, lon, dep, az, inc)
\\
\hline
resp
&
2*r
&
real(S.resp{[}:{]}) followed by imag(S.resp{[}:{]})
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

Convert resp with \sphinxcode{\sphinxupquote{resp = rr{[}1:r{]} + im*rr{[}r+1:2*r{]}}} and reshape to a two-column array with \sphinxcode{\sphinxupquote{r}} rows. The first column of the new, complex-valued \sphinxcode{\sphinxupquote{resp}} field holds zeros, the second holds poles.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{UInt8 values}\label{\detokenize{src/Appendices/seisdata_fileformat:id9}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{1}{6}|\X{1}{6}|\X{4}{6}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
N
&\sphinxstyletheadfamily 
Meaning
\\
\hline
c
&
1
&
separator for notes
\\
\hline
ex
&
1
&
type code for S.x
\\
\hline
id
&
15
&
S.id
\\
\hline
units
&
L\_units
&
S.units
\\
\hline
src
&
L\_src
&
S.src
\\
\hline
name
&
L\_name
&
S.name
\\
\hline
notes
&
L\_notes
&
S.notes joined as a string with delimiter \sphinxcode{\sphinxupquote{c}}
\\
\hline
xc
&
lxc
&
Blosc-compressed S.x
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

S.misc is written last, after the compressed S.x


\subsubsection{Storing misc}
\label{\detokenize{src/Appendices/seisdata_fileformat:storing-misc}}
\sphinxcode{\sphinxupquote{:misc}} is a Dict\{String,Any\} for both SeisData and SeisHdr, with limited support for key value types. Structural overview:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{L\PYGZus{}keys}
\PYG{n}{char\PYGZus{}separator}  \PYG{c+c1}{\PYGZsh{} for keys}
\PYG{n}{keys}            \PYG{c+c1}{\PYGZsh{} joined as a string}
\PYG{c+c1}{\PYGZsh{} for each key k}
\PYG{n}{type\PYGZus{}code}       \PYG{c+c1}{\PYGZsh{} UInt8 code for misc[k]}
\PYG{n}{value}           \PYG{c+c1}{\PYGZsh{} value of misc[k]}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{\sphinxstyleliteralintitle{\sphinxupquote{:misc}} keys}\label{\detokenize{src/Appendices/seisdata_fileformat:id10}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{5}{47}|\X{32}{47}|\X{5}{47}|\X{5}{47}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Meaning
&\sphinxstyletheadfamily 
T
&\sphinxstyletheadfamily 
N
\\
\hline
\sphinxcode{\sphinxupquote{L}}
&
length of keys string
&
i64
&
1
\\
\hline
\sphinxcode{\sphinxupquote{p}}
&
character separator
&
u8
&
1
\\
\hline
\sphinxcode{\sphinxupquote{K}}
&
string of keys
&
u8
&
p
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Supported \sphinxstyleliteralintitle{\sphinxupquote{:misc}} value Types}\label{\detokenize{src/Appendices/seisdata_fileformat:id11}}\label{\detokenize{src/Appendices/seisdata_fileformat:smt}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{1}{14}|\X{6}{14}|\X{1}{14}|\X{6}{14}|}
\hline
\sphinxstyletheadfamily 
code
&\sphinxstyletheadfamily 
value Type
&\sphinxstyletheadfamily 
code
&\sphinxstyletheadfamily 
value Type
\\
\hline
0
&
Char
&
128
&
Array\{Char,1\}
\\
\hline
1
&
String
&
129
&
Array\{String,1\}
\\
\hline
16
&
UInt8
&
144
&
Array\{UInt8,1\}
\\
\hline
17
&
UInt16
&
145
&
Array\{UInt16,1\}
\\
\hline
18
&
UInt32
&
146
&
Array\{UInt32,1\}
\\
\hline
19
&
UInt64
&
147
&
Array\{UInt64,1\}
\\
\hline
20
&
UInt128
&
148
&
Array\{UInt128,1\}
\\
\hline
32
&
Int8
&
160
&
Array\{Int8,1\}
\\
\hline
33
&
Int16
&
161
&
Array\{Int16,1\}
\\
\hline
34
&
Int32
&
162
&
Array\{Int32,1\}
\\
\hline
35
&
Int64
&
163
&
Array\{Int64,1\}
\\
\hline
36
&
Int128
&
164
&
Array\{Int128,1\}
\\
\hline
48
&
Float16
&
176
&
Array\{Float16,1\}
\\
\hline
49
&
Float32
&
177
&
Array\{Float32,1\}
\\
\hline
50
&
Float64
&
178
&
Array\{Float64,1\}
\\
\hline
80
&
Complex\{UInt8\}
&
208
&
Array\{Complex\{UInt8\},1\}
\\
\hline
81
&
Complex\{UInt16\}
&
209
&
Array\{Complex\{UInt16\},1\}
\\
\hline
82
&
Complex\{UInt32\}
&
210
&
Array\{Complex\{UInt32\},1\}
\\
\hline
83
&
Complex\{UInt64\}
&
211
&
Array\{Complex\{UInt64\},1\}
\\
\hline
84
&
Complex\{UInt128\}
&
212
&
Array\{Complex\{UInt128\},1\}
\\
\hline
96
&
Complex\{Int8\}
&
224
&
Array\{Complex\{Int8\},1\}
\\
\hline
97
&
Complex\{Int16\}
&
225
&
Array\{Complex\{Int16\},1\}
\\
\hline
98
&
Complex\{Int32\}
&
226
&
Array\{Complex\{Int32\},1\}
\\
\hline
99
&
Complex\{Int64\}
&
227
&
Array\{Complex\{Int64\},1\}
\\
\hline
100
&
Complex\{Int128\}
&
228
&
Array\{Complex\{Int128\},1\}
\\
\hline
112
&
Complex\{Float16\}
&
240
&
Array\{Complex\{Float16\},1\}
\\
\hline
113
&
Complex\{Float32\}
&
241
&
Array\{Complex\{Float32\},1\}
\\
\hline
114
&
Complex\{Float64\}
&
242
&
Array\{Complex\{Float64\},1\}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

Julia code for converting between data types and UInt8 type codes is given below.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{findtype}\PYG{p}{(}\PYG{n}{c}\PYG{p}{:}\PYG{p}{:}\PYG{n}{UInt8}\PYG{p}{,} \PYG{n}{T}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Array}\PYG{p}{\PYGZob{}}\PYG{n}{Type}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)} \PYG{o}{=} \PYG{n}{T}\PYG{p}{[}\PYG{n}{findfirst}\PYG{p}{(}\PYG{p}{[}\PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{2}\PYG{o}{\PYGZca{}}\PYG{n}{c} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{T}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{function} \PYG{n}{code2typ}\PYG{p}{(}\PYG{n}{c}\PYG{p}{:}\PYG{p}{:}\PYG{n}{UInt8}\PYG{p}{)}
  \PYG{n}{t} \PYG{o}{=} \PYG{n}{Any}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Type}
  \PYG{k}{if} \PYG{n}{c} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mh}{0x80}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{Array}\PYG{p}{\PYGZob{}}\PYG{n}{code2typ}\PYG{p}{(}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{l+m+mh}{0x80}\PYG{p}{)}\PYG{p}{\PYGZcb{}}
  \PYG{n}{elseif} \PYG{n}{c} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mh}{0x40}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{Complex}\PYG{p}{\PYGZob{}}\PYG{n}{code2typ}\PYG{p}{(}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{l+m+mh}{0x40}\PYG{p}{)}\PYG{p}{\PYGZcb{}}
  \PYG{n}{elseif} \PYG{n}{c} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mh}{0x30}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{findtype}\PYG{p}{(}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{l+m+mh}{0x2f}\PYG{p}{,} \PYG{n}{Array}\PYG{p}{\PYGZob{}}\PYG{n}{Type}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{(}\PYG{n}{subtypes}\PYG{p}{(}\PYG{n}{AbstractFloat}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
  \PYG{n}{elseif} \PYG{n}{c} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mh}{0x20}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{findtype}\PYG{p}{(}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{l+m+mh}{0x20}\PYG{p}{,} \PYG{n}{Array}\PYG{p}{\PYGZob{}}\PYG{n}{Type}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{(}\PYG{n}{subtypes}\PYG{p}{(}\PYG{n}{Signed}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
  \PYG{n}{elseif} \PYG{n}{c} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mh}{0x10}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{findtype}\PYG{p}{(}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{l+m+mh}{0x10}\PYG{p}{,} \PYG{n}{Array}\PYG{p}{\PYGZob{}}\PYG{n}{Type}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{(}\PYG{n}{subtypes}\PYG{p}{(}\PYG{n}{Unsigned}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
  \PYG{n}{elseif} \PYG{n}{c} \PYG{o}{==} \PYG{l+m+mh}{0x01}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{String}
  \PYG{n}{elseif} \PYG{n}{c} \PYG{o}{==} \PYG{l+m+mh}{0x00}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{Char}
  \PYG{k}{else}
    \PYG{n}{t} \PYG{o}{=} \PYG{n}{Any}
  \PYG{n}{end}
  \PYG{k}{return} \PYG{n}{t}
\PYG{n}{end}

\PYG{n}{tos}\PYG{p}{(}\PYG{n}{t}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Type}\PYG{p}{)} \PYG{o}{=} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{Int64}\PYG{p}{,} \PYG{n}{log2}\PYG{p}{(}\PYG{n}{sizeof}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{function} \PYG{n}{typ2code}\PYG{p}{(}\PYG{n}{t}\PYG{p}{:}\PYG{p}{:}\PYG{n}{Type}\PYG{p}{)}
  \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mh}{0xff}
  \PYG{k}{if} \PYG{n}{t} \PYG{o}{==} \PYG{n}{Char}
    \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mh}{0x00}
  \PYG{n}{elseif} \PYG{n}{t} \PYG{o}{==} \PYG{n}{String}
    \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mh}{0x01}
  \PYG{n}{elseif} \PYG{n}{t} \PYG{o}{\PYGZlt{}}\PYG{p}{:} \PYG{n}{Unsigned}
    \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mh}{0x10} \PYG{o}{+} \PYG{n}{tos}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
  \PYG{n}{elseif} \PYG{n}{t} \PYG{o}{\PYGZlt{}}\PYG{p}{:} \PYG{n}{Signed}
    \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mh}{0x20} \PYG{o}{+} \PYG{n}{tos}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}
  \PYG{n}{elseif} \PYG{n}{t} \PYG{o}{\PYGZlt{}}\PYG{p}{:} \PYG{n}{AbstractFloat}
    \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mh}{0x30} \PYG{o}{+} \PYG{n}{tos}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
  \PYG{n}{elseif} \PYG{n}{t} \PYG{o}{\PYGZlt{}}\PYG{p}{:} \PYG{n}{Complex}
    \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mh}{0x40} \PYG{o}{+} \PYG{n}{typ2code}\PYG{p}{(}\PYG{n}{real}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}
  \PYG{n}{elseif} \PYG{n}{t} \PYG{o}{\PYGZlt{}}\PYG{p}{:} \PYG{n}{Array}
    \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mh}{0x80} \PYG{o}{+} \PYG{n}{typ2code}\PYG{p}{(}\PYG{n}{eltype}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{)}
  \PYG{n}{end}
  \PYG{k}{return} \PYG{n}{UInt8}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
\PYG{n}{end}
\end{sphinxVerbatim}

Type “Any” is provided as a default; it is not supported.


\paragraph{Standard Types in \sphinxstyleliteralintitle{\sphinxupquote{:misc}}}
\label{\detokenize{src/Appendices/seisdata_fileformat:standard-types-in-misc}}
Most values in \sphinxcode{\sphinxupquote{:misc}} are saved as a {\hyperref[\detokenize{src/Appendices/seisdata_fileformat:smt}]{\sphinxcrossref{\DUrole{std,std-ref}{UInt8 code}}}} followed by the value itself.


\paragraph{Unusual Types in \sphinxstyleliteralintitle{\sphinxupquote{:misc}}}
\label{\detokenize{src/Appendices/seisdata_fileformat:unusual-types-in-misc}}
The tables below describe how to read non-bitstype data into \sphinxcode{\sphinxupquote{:misc}}.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Array\{String\}}\label{\detokenize{src/Appendices/seisdata_fileformat:id12}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{4}{44}|\X{32}{44}|\X{4}{44}|\X{4}{44}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Meaning
&\sphinxstyletheadfamily 
T
&\sphinxstyletheadfamily 
N
\\
\hline
nd
&
array dimensionality
&
u8
&
1
\\
\hline
d
&
array dimensions
&
i64
&
nd
\\
\hline&
if d!={[}0{]}:
&&\\
\hline
sep
&
string separator
&
c
&
1
\\
\hline
L\_S
&
length of char array
&
i64
&
1
\\
\hline
S
&
string array as chars
&
u8
&
L\_S
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

If d={[}0{]}, indicating an empty String array, set S to an empty String array and do not read sep, L\_S, or S.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Array\{Complex\}}\label{\detokenize{src/Appendices/seisdata_fileformat:id13}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{4}{44}|\X{32}{44}|\X{4}{44}|\X{4}{44}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Meaning
&\sphinxstyletheadfamily 
T
&\sphinxstyletheadfamily 
N
\\
\hline
nd
&
array dimensionality
&
u8
&
1
\\
\hline
d
&
array dimensions
&
i64
&
nd
\\
\hline
rr
&
real part of array
&
\(\tau\)
&
d
\\
\hline
ii
&
imaginary part of array
&
\(\tau\)
&
d
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

Here, \(\tau\) denotes the type of the real part of one element of v.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{Array\{Real\}}\label{\detokenize{src/Appendices/seisdata_fileformat:id14}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{4}{44}|\X{32}{44}|\X{4}{44}|\X{4}{44}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Meaning
&\sphinxstyletheadfamily 
T
&\sphinxstyletheadfamily 
N
\\
\hline
nd
&
array dimensionality
&
u8
&
1
\\
\hline
d
&
array dimensions
&
i64
&
nd
\\
\hline
v
&
array values
&
\(\tau\)
&
d
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

Here, \(\tau\) denotes the type of one element of v.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxcaption{String}\label{\detokenize{src/Appendices/seisdata_fileformat:id15}}
\sphinxaftercaption
\begin{tabular}[t]{|\X{4}{44}|\X{32}{44}|\X{4}{44}|\X{4}{44}|}
\hline
\sphinxstyletheadfamily 
Var
&\sphinxstyletheadfamily 
Meaning
&\sphinxstyletheadfamily 
T
&\sphinxstyletheadfamily 
N
\\
\hline
L\_S
&
length of string
&
i64
&
1
\\
\hline
S
&
string
&
u8
&
L\_S
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{SeisEvent}
\label{\detokenize{src/Appendices/seisdata_fileformat:seisevent}}
A SeisEvent structure is stored as a SeisHdr object followed by a SeisData object. However, the combination of SeisHdr and SeisData objects that comprises a SeisEvent object counts as one object, not two, in the file TOC.


\section{Data Requests Syntax}
\label{\detokenize{src/Appendices/web_syntax:data-requests-syntax}}\label{\detokenize{src/Appendices/web_syntax::doc}}

\subsection{Channel ID Syntax}
\label{\detokenize{src/Appendices/web_syntax:channel-id-syntax}}\label{\detokenize{src/Appendices/web_syntax:cid}}
\sphinxcode{\sphinxupquote{NN.SSSSS.LL.CC}} (net.sta.loc.cha, separated by periods) is the expected syntax for all web functions. The maximum field width in characters corresponds to the length of each field (e.g. 2 for network). Fields can’t contain whitespace.

\sphinxcode{\sphinxupquote{NN.SSSSS.LL.CC.T}} (net.sta.loc.cha.tflag) is allowed in SeedLink. \sphinxcode{\sphinxupquote{T}} is a single-character data type flag and must be one of \sphinxcode{\sphinxupquote{DECOTL}}: Data, Event, Calibration, blOckette, Timing, or Logs. Calibration, timing, and logs are not in the scope of SeisIO and may crash SeedLink sessions.

The table below specifies valid types and expected syntax for channel lists.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|*{3}{\X{1}{3}|}}
\hline
\sphinxstyletheadfamily 
Type
&\sphinxstyletheadfamily 
Description
&\sphinxstyletheadfamily 
Example
\\
\hline
String
&
Comma-delineated
list of IDs
&
“PB.B004.01.BS1,PB.B002.01.BS1”
\\
\hline
Array\{String,1\}
&
String array, one
ID string per entry
&
{[}“PB.B004.01.BS1”,”PB.B002.01.BS1”{]}
\\
\hline
Array\{String,2\}
&
String array, one
ID string per row
&\begin{description}
\item[{{[}“PB” “B004” “01” “BS1”;}] \leavevmode
“PB” “B002” “01” “BS1”{]}

\end{description}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

The expected component order is always network, station, location, channel; thus, “UW.TDH..EHZ” is OK, but “UW.TDH.EHZ” fails.
\index{chanspec() (built-in function)@\spxentry{chanspec()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/web_syntax:chanspec}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{chanspec}}}{}{}
\end{fulllineitems}


Type \sphinxcode{\sphinxupquote{?chanspec}} in Julia to print the above info. to stdout.


\subsubsection{Wildcards and Blanks}
\label{\detokenize{src/Appendices/web_syntax:wildcards-and-blanks}}
Allowed wildcards are client-specific.
\begin{itemize}
\item {} 
The LOC field can be left blank in any client: \sphinxcode{\sphinxupquote{"UW.ELK..EHZ"}} and \sphinxcode{\sphinxupquote{{[}"UW" "ELK" "" "EHZ"{]}}} are all valid. Blank LOC fields are set to \sphinxcode{\sphinxupquote{-{-}}} in IRIS, \sphinxcode{\sphinxupquote{*}} in FDSN, and \sphinxcode{\sphinxupquote{??}} in SeedLink.

\item {} 
\sphinxcode{\sphinxupquote{?}} acts as a single-character wildcard in FDSN \& SeedLink. Thus, \sphinxcode{\sphinxupquote{CC.VALT..???}} is valid.

\item {} 
\sphinxcode{\sphinxupquote{*}} acts as a multi-character wildcard in FDSN. Thus, \sphinxcode{\sphinxupquote{CC.VALT..*}} and \sphinxcode{\sphinxupquote{CC.VALT..???}} behave identically in FDSN.

\item {} 
Partial specifiers are OK, but a network and station are always required: \sphinxcode{\sphinxupquote{"UW.EL?"}} is OK, \sphinxcode{\sphinxupquote{".ELK.."}} fails.

\end{itemize}


\subsubsection{Channel Configuration Files}
\label{\detokenize{src/Appendices/web_syntax:channel-configuration-files}}\label{\detokenize{src/Appendices/web_syntax:ccfg}}
One entry per line, ASCII text, format NN.SSSSS.LL.CCC.D. Due to client-specific wildcard rules, the most versatile configuration files are those that specify each channel most completely:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{} This only works with SeedLink
GE.ISP..BH?.D
NL.HGN
MN.AQU..BH?
MN.AQU..HH?
UW.KMO
CC.VALT..BH?.D

\PYGZsh{} This works with FDSN and SeedLink, but not IRIS
GE.ISP..BH?
NL.HGN
MN.AQU..BH?
MN.AQU..HH?
UW.KMO
CC.VALT..BH?

\PYGZsh{} This works with all three:
GE.ISP..BHZ
GE.ISP..BHN
GE.ISP..BHE
MN.AQU..BHZ
MN.AQU..BHN
MN.AQU..BHE
MN.AQU..HHZ
MN.AQU..HHN
MN.AQU..HHE
UW.KMO..EHZ
CC.VALT..BHZ
CC.VALT..BHN
CC.VALT..BHE
\end{sphinxVerbatim}


\subsubsection{Server List}
\label{\detokenize{src/Appendices/web_syntax:server-list}}\label{\detokenize{src/Appendices/web_syntax:servers}}\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
String
&\sphinxstyletheadfamily 
Source
\\
\hline
BGR
&
\sphinxurl{http://eida.bgr.de}
\\
\hline
EMSC
&
\sphinxurl{http://www.seismicportal.eu}
\\
\hline
ETH
&
\sphinxurl{http://eida.ethz.ch}
\\
\hline
GEONET
&
\sphinxurl{http://service.geonet.org.nz}
\\
\hline
GFZ
&
\sphinxurl{http://geofon.gfz-potsdam.de}
\\
\hline
ICGC
&
\sphinxurl{http://ws.icgc.cat}
\\
\hline
INGV
&
\sphinxurl{http://webservices.ingv.it}
\\
\hline
IPGP
&
\sphinxurl{http://eida.ipgp.fr}
\\
\hline
IRIS
&
\sphinxurl{http://service.iris.edu}
\\
\hline
ISC
&
\sphinxurl{http://isc-mirror.iris.washington.edu}
\\
\hline
KOERI
&
\sphinxurl{http://eida.koeri.boun.edu.tr}
\\
\hline
LMU
&
\sphinxurl{http://erde.geophysik.uni-muenchen.de}
\\
\hline
NCEDC
&
\sphinxurl{http://service.ncedc.org}
\\
\hline
NIEP
&
\sphinxurl{http://eida-sc3.infp.ro}
\\
\hline
NOA
&
\sphinxurl{http://eida.gein.noa.gr}
\\
\hline
ORFEUS
&
\sphinxurl{http://www.orfeus-eu.org}
\\
\hline
RESIF
&
\sphinxurl{http://ws.resif.fr}
\\
\hline
SCEDC
&
\sphinxurl{http://service.scedc.caltech.edu}
\\
\hline
TEXNET
&
\sphinxurl{http://rtserve.beg.utexas.edu}
\\
\hline
USGS
&
\sphinxurl{http://earthquake.usgs.gov}
\\
\hline
USP
&
\sphinxurl{http://sismo.iag.usp.br}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{seis\_www() (built-in function)@\spxentry{seis\_www()}\spxextra{built-in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{src/Appendices/web_syntax:seis_www}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{seis\_www}}}{}{}
\end{fulllineitems}


Type \sphinxcode{\sphinxupquote{?seis\_www}} in Julia to print the above info. to stdout.
\end{quote}


\subsection{Time Syntax}
\label{\detokenize{src/Appendices/web_syntax:time-syntax}}\label{\detokenize{src/Appendices/web_syntax:id1}}
Specify time inputs for web queries as a DateTime, Real, or String. The latter must take the form YYYY-MM-DDThh:mm:ss.nnn, where \sphinxcode{\sphinxupquote{T}} is the uppercase character \sphinxtitleref{T} and \sphinxcode{\sphinxupquote{nnn}} denotes milliseconds; incomplete time strings treat missing fields as 0.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{40}|\X{8}{40}|\X{24}{40}|}
\hline
\sphinxstyletheadfamily 
type(s)
&\sphinxstyletheadfamily 
type(t)
&\sphinxstyletheadfamily 
behavior
\\
\hline
DT
&
DT
&
Sort only
\\
\hline
R
&
DT
&
Add \sphinxcode{\sphinxupquote{s}} seconds to \sphinxcode{\sphinxupquote{t}}
\\
\hline
DT
&
R
&
Add \sphinxcode{\sphinxupquote{t}} seconds to \sphinxcode{\sphinxupquote{s}}
\\
\hline
S
&
R
&
Convert \sphinxcode{\sphinxupquote{s}} to DateTime, add \sphinxcode{\sphinxupquote{t}}
\\
\hline
R
&
S
&
Convert \sphinxcode{\sphinxupquote{t}} to DateTime, add \sphinxcode{\sphinxupquote{s}}
\\
\hline
R
&
R
&
Add \sphinxcode{\sphinxupquote{s, t}} seconds to \sphinxcode{\sphinxupquote{now()}}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

(above, R = Real, DT = DateTime, S = String, I = Integer)


\section{SeisIO Standard Keywords}
\label{\detokenize{src/Appendices/keywords:seisio-standard-keywords}}\label{\detokenize{src/Appendices/keywords:dkw}}\label{\detokenize{src/Appendices/keywords::doc}}
SeisIO.KW is a memory-resident structure of default values for common keywords
used by package functions. KW has one substructure, SL, with keywords specific
to SeedLink. These defaults can be modified, e.g., SeisIO.KW.nev=2 changes the
default for nev to 2.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
KW
&\sphinxstyletheadfamily 
Default
&\sphinxstyletheadfamily 
T \sphinxfootnotemark[1]
&\sphinxstyletheadfamily 
Meaning
\\
\hline%
\begin{footnotetext}[1]\sphinxAtStartFootnote
Types: A = Array, B = Boolean, C = Char, DT = DateTime, F = Float, I = Integer, R = Real, S = String, U8 = Unsigned 8-bit integer
%
\end{footnotetext}\ignorespaces 
evw
&
{[}600.0, 600.0{]}
&
A\{F,1\}
&
time search window {[}o-evw{[}1{]}, o+evw{[}2{]}{]}
\\
\hline
fmt
&
“miniseed”
&
S
&
request data format
\\
\hline
mag
&
{[}6.0, 9.9{]}
&
A\{F,1\}
&
magnitude range for queries
\\
\hline
nd
&
1
&
I
&
number of days per subrequest
\\
\hline
nev
&
1
&
I
&
number of events returned per query
\\
\hline
nx\_add
&
360000
&
I
&
length increase of undersized data array
\\
\hline
nx\_new
&
8640000
&
I
&
number of samples for a new channel
\\
\hline
opts
&
“”
&
S
&
user-specified options %
\begin{footnote}[2]\sphinxAtStartFootnote
String is passed as-is, e.g. “szsrecs=true\&repo=realtime” for FDSN. String should not begin with an ampersand.
%
\end{footnote}
\\
\hline
pha
&
“P”
&
S
&
seismic phase arrival times to retrieve
\\
\hline
rad
&
{[}{]}
&
A\{F,1\}
&
radial search region %
\begin{footnote}[3]\sphinxAtStartFootnote
Specify region \sphinxstylestrong{{[}center\_lat, center\_lon, min\_radius, max\_radius, dep\_min, dep\_max{]}}, with lat, lon, and radius in decimal degrees (°) and depth in km with + = down. Depths are only used for earthquake searches.
%
\end{footnote}
\\
\hline
reg
&
{[}{]}
&
A\{F,1\}
&
rectangular search region %
\begin{footnote}[4]\sphinxAtStartFootnote
Specify region \sphinxstylestrong{{[}lat\_min, lat\_max, lon\_min, lon\_max, dep\_min, dep\_max{]}}, with lat, lon in decimal degrees (°) and depth in km with + = down. Depths are only used for earthquake searches.
%
\end{footnote}
\\
\hline
si
&
true
&
B
&
autofill station info on data req? %
\begin{footnote}[5]\sphinxAtStartFootnote
Not used with IRISWS.
%
\end{footnote}
\\
\hline
to
&
30
&
I
&
read timeout for web requests (s)
\\
\hline
v
&
0
&
I
&
verbosity
\\
\hline
w
&
false
&
B
&
write requests to disc? %
\begin{footnote}[6]\sphinxAtStartFootnote
\sphinxstylestrong{-v=0} = quiet; 1 = verbose, 2 = debug; 3 = verbose debug
%
\end{footnote}
\\
\hline
y
&
false
&
B
&
sync data after web request? %
\begin{footnote}[7]\sphinxAtStartFootnote
If \sphinxstylestrong{-w=true}, a file name is automatically generated from the request parameters, in addition to parsing data to a SeisData structure. Files are created from the raw download even if data processing fails, in contrast to get\_data(… wsac=true).
%
\end{footnote}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Table Footnotes}


\subsection{SeedLink Keywords}
\label{\detokenize{src/Appendices/keywords:seedlink-keywords}}
Change these with SeisIO.KW.SL.{[}key{]} = value, e.g., SeisIO.KW.SL.refresh = 30.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{48}|\X{8}{48}|\X{8}{48}|\X{24}{48}|}
\hline
\sphinxstyletheadfamily 
kw
&\sphinxstyletheadfamily 
def
&\sphinxstyletheadfamily 
type
&\sphinxstyletheadfamily 
meaning
\\
\hline
gap
&
3600
&
R
&
a stream with no data in \textgreater{}gap seconds is considered offline
\\
\hline
kai
&
600
&
R
&
keepalive interval (s)
\\
\hline
mode
&
“DATA”
&
I
&
“TIME”, “DATA”, or “FETCH”
\\
\hline
port
&
18000
&
I
&
port number
\\
\hline
refresh
&
20
&
R
&
base refresh interval (s) %
\begin{footnote}[8]\sphinxAtStartFootnote
This value is modified slightly by each SeedLink session to minimize the risk of congestion
%
\end{footnote}
\\
\hline
x\_on\_err
&
true
&
Bool
&
exit on error?
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\subsubsection*{Table Footnotes}


\section{Examples}
\label{\detokenize{src/Appendices/examples:examples}}\label{\detokenize{src/Appendices/examples:webex}}\label{\detokenize{src/Appendices/examples::doc}}

\subsection{FDSN data query}
\label{\detokenize{src/Appendices/examples:fdsn-data-query}}
1. Download 10 minutes of data from four stations at Mt. St. Helens (WA, USA), delete the low-gain channels, and save as SAC files in the current directory.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S} \PYG{o}{=} \PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FDSN}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CC.VALT, UW.SEP, UW.SHW, UW.HSR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{src}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IRIS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{600}\PYG{p}{)}
\PYG{n}{S} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SHW.ELZ..UW}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{S} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HSR.ELZ..UW}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{writesac}\PYG{p}{(}\PYG{n}{S}\PYG{p}{)}
\end{sphinxVerbatim}

2. Get 5 stations, 2 networks, all channels, last 600 seconds of data at IRIS

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CHA} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CC.PALM, UW.HOOD, UW.TIMB, CC.HIYU, UW.TDH}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{TS} \PYG{o}{=} \PYG{n}{u2d}\PYG{p}{(}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{TT} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{600}
\PYG{n}{S} \PYG{o}{=} \PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FDSN}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{CHA}\PYG{p}{,} \PYG{n}{src}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IRIS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{n}{TS}\PYG{p}{,} \PYG{n}{t}\PYG{o}{=}\PYG{n}{TT}\PYG{p}{)}
\end{sphinxVerbatim}

3. A request to FDSN Potsdam, time-synchronized, with some verbosity

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ts} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2011\PYGZhy{}03\PYGZhy{}11T06:00:00}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{te} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2011\PYGZhy{}03\PYGZhy{}11T06:05:00}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{R} \PYG{o}{=} \PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FDSN}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GE.BKB..BH?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{src}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{GFZ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{n}{ts}\PYG{p}{,} \PYG{n}{t}\PYG{o}{=}\PYG{n}{te}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{n}{true}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{FDSN station query}
\label{\detokenize{src/Appendices/examples:fdsn-station-query}}
A sample FDSN station query

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S} \PYG{o}{=} \PYG{n}{FDSNsta}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CC.VALT..,PB.B001..BS?,PB.B001..E??}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{FDSN event header/data query}
\label{\detokenize{src/Appendices/examples:fdsn-event-header-data-query}}
Get seismic and strainmeter records for the P-wave of the Tohoku-Oki great earthquake on two borehole stations and write to native SeisData format:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S} \PYG{o}{=} \PYG{n}{FDSNevt}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{201103110547}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PB.B004..EH?,PB.B004..BS?,PB.B001..BS?,PB.B001..EH?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{wseis}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{201103110547\PYGZus{}evt.seis}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{S}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{IRISWS data query}
\label{\detokenize{src/Appendices/examples:irisws-data-query}}
Note that the “src” keyword is not used in IRIS queries.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Get trace data from IRISws from \sphinxcode{\sphinxupquote{TS}} to \sphinxcode{\sphinxupquote{TT}} at channels \sphinxcode{\sphinxupquote{CHA}}

\end{enumerate}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
S = SeisData()
CHA = \PYGZdq{}UW.TDH..EHZ, UW.VLL..EHZ, CC.VALT..BHZ\PYGZdq{}
TS = u2d(time()\PYGZhy{}86400)
TT = 600
get\PYGZus{}data!(S, \PYGZdq{}IRIS\PYGZdq{}, CHA, s=TS, t=TT)
\end{sphinxVerbatim}

2. Get synchronized trace data from IRISws with a 55-second timeout on HTTP requests, written directly to disk.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CHA} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UW.TDH..EHZ, UW.VLL..EHZ, CC.VALT..BHZ}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{TS} \PYG{o}{=} \PYG{n}{u2d}\PYG{p}{(}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{TT} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{600}
\PYG{n}{S} \PYG{o}{=} \PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IRIS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{CHA}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{n}{TS}\PYG{p}{,} \PYG{n}{t}\PYG{o}{=}\PYG{n}{TT}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{n}{true}\PYG{p}{,} \PYG{n}{to}\PYG{o}{=}\PYG{l+m+mi}{55}\PYG{p}{,} \PYG{n}{w}\PYG{o}{=}\PYG{n}{true}\PYG{p}{)}
\end{sphinxVerbatim}

3. Request 10 minutes of continuous vertical-component data from a small May 2016 earthquake swarm at Mt. Hood, OR, USA:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{STA} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UW.HOOD.\PYGZhy{}\PYGZhy{}.BHZ,CC.TIMB.\PYGZhy{}\PYGZhy{}.EHZ}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{TS} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2016\PYGZhy{}05\PYGZhy{}16T14:50:00}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;} \PYG{n}{TE} \PYG{o}{=} \PYG{l+m+mi}{600}
\PYG{n}{S} \PYG{o}{=} \PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IRIS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{STA}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{n}{TS}\PYG{p}{,} \PYG{n}{t}\PYG{o}{=}\PYG{n}{TE}\PYG{p}{)}
\end{sphinxVerbatim}

4. Grab data from a predetermined time window in two different formats

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ts} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2016\PYGZhy{}03\PYGZhy{}23T23:10:00}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{te} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2016\PYGZhy{}03\PYGZhy{}23T23:17:00}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{S} \PYG{o}{=} \PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IRIS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CC.JRO..BHZ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{n}{ts}\PYG{p}{,} \PYG{n}{t}\PYG{o}{=}\PYG{n}{te}\PYG{p}{,} \PYG{n}{fmt}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sacbl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{T} \PYG{o}{=} \PYG{n}{get\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{IRIS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CC.JRO..BHZ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{n}{ts}\PYG{p}{,} \PYG{n}{t}\PYG{o}{=}\PYG{n}{te}\PYG{p}{,} \PYG{n}{fmt}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{miniseed}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{SeedLink sessions}
\label{\detokenize{src/Appendices/examples:seedlink-sessions}}
1. An attended SeedLink session in DATA mode. Initiate a SeedLink session in DATA mode using config file SL.conf and write all packets received directly to file (in addition to parsing to S itself). Set nominal refresh interval for checking for new data to 10 s. A mini-seed file will be generated automatically.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
S = SeisData()
SeedLink!(S, \PYGZdq{}SL.conf\PYGZdq{}, mode=\PYGZdq{}DATA\PYGZdq{}, r=10, w=true)
\end{sphinxVerbatim}

2. An unattended SeedLink download in TIME mode. Get the next two minutes of data from stations GPW, MBW, SHUK in the UW network. Put the Julia REPL to sleep while the request fills. If the connection is still open, close it (SeedLink’s time bounds arent precise in TIME mode, so this may or may not be necessary). Pause briefly so that the last data packets are written. Synchronize results and write data in native SeisIO file format.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sta = \PYGZdq{}UW.GPW,UW.MBW,UW.SHUK\PYGZdq{}
s0 = now()
S = SeedLink(sta, mode=\PYGZdq{}TIME\PYGZdq{}, s=s0, t=120, r=10)
sleep(180)
isopen(S.c[1]) \PYGZam{}\PYGZam{} close(S.c[1])
sleep(20)
sync!(S)
fname = string(\PYGZdq{}GPW\PYGZus{}MBW\PYGZus{}SHUK\PYGZdq{}, s0, \PYGZdq{}.seis\PYGZdq{})
wseis(fname, S)
\end{sphinxVerbatim}

3. A SeedLink session in TIME mode

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sta} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UW.GPW, UW.MBW, UW.SHUK}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{S1} \PYG{o}{=} \PYG{n}{SeedLink}\PYG{p}{(}\PYG{n}{sta}\PYG{p}{,} \PYG{n}{mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TIME}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{t}\PYG{o}{=}\PYG{l+m+mi}{120}\PYG{p}{)}
\end{sphinxVerbatim}

4. A SeedLink session in DATA mode with multiple servers, including a config file. Data are parsed roughly every 10 seconds. A total of 5 minutes of data are requested.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sta = [\PYGZdq{}CC.SEP\PYGZdq{}, \PYGZdq{}UW.HDW\PYGZdq{}]
\PYGZsh{} To ensure precise timing, we\PYGZsq{}ll pass d0 and d1 as strings
st = 0.0
en = 300.0
dt = en\PYGZhy{}st
(d0,d1) = parsetimewin(st,en)

S = SeisData()
SeedLink!(S, sta, mode=\PYGZdq{}TIME\PYGZdq{}, r=10.0, s=d0, t=d1)
println(stdout, \PYGZdq{}...first link initialized...\PYGZdq{})

\PYGZsh{} Seedlink with a config file
config\PYGZus{}file = \PYGZdq{}seedlink.conf\PYGZdq{}
SeedLink!(S, config\PYGZus{}file, r=10.0, mode=\PYGZdq{}TIME\PYGZdq{}, s=d0, t=d1)
println(stdout, \PYGZdq{}...second link initialized...\PYGZdq{})

\PYGZsh{} Seedlink with a config string
SeedLink!(S, \PYGZdq{}CC.VALT..???, UW.ELK..EHZ\PYGZdq{}, mode=\PYGZdq{}TIME\PYGZdq{}, r=10.0, s=d0, t=d1)
println(stdout, \PYGZdq{}...third link initialized...\PYGZdq{})
\end{sphinxVerbatim}



\renewcommand{\indexname}{Index}
\printindex
\end{document}